<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>正则表达式真的很骚，可惜你不会写！！！</title>
      <link href="2021/06/03/zheng-ze-biao-da-shi/"/>
      <url>2021/06/03/zheng-ze-biao-da-shi/</url>
      
        <content type="html"><![CDATA[<h1 id="正则表达式真的很骚，可惜你不会写！！！"><a href="#正则表达式真的很骚，可惜你不会写！！！" class="headerlink" title="正则表达式真的很骚，可惜你不会写！！！"></a>正则表达式真的很骚，可惜你不会写！！！</h1><p>本文旨在用最通俗的语言讲述最枯燥的基本知识</p><blockquote><p>文章提纲：</p><ol><li>元字符</li><li>重复限定符</li><li>分组</li><li>转义</li><li>条件或</li><li>区间</li></ol></blockquote><p>正则表达式在几乎所有语言中都可以使用，无论是前端的JavaScript、还是后端的Java、c#。他们都提供相应的接口/函数支持正则表达式。</p><p>但很神奇的是：*<strong>无论你大学选择哪一门计算机语言，都没有关于正则表达式的课程给你修，在你学会正则之前，你只能看着那些正则大师们，写了一串外星文似的字符串，替代了你用一大篇幅的if else代码来做一些内容校验*</strong>。</p><p>既然喜欢，那就动手学呗，可当你百度出一一堆相关资料时，你发现无一不例外的枯燥至极，难以学习（实话说，当年不理君也是这样的心态😂😂）。</p><p>下面，不理君尝试用一种比较通俗点的方式讲一下正则，让你能在读完之后，自己写出一些简单的正则，再不济，能看到别人写的正则，那也不错了。</p><h3 id="1-元字符"><a href="#1-元字符" class="headerlink" title="1.元字符"></a>1.元字符</h3><p>万物皆有源，正则也是如此，元字符是构造正则表达式的一种基本元素。<br>我们先来记几个常用的元字符：</p><table><thead><tr><th align="center">元字符</th><th align="left">说明</th></tr></thead><tbody><tr><td align="center">.</td><td align="left">匹配除换行符以外的任意字符</td></tr><tr><td align="center">\w</td><td align="left">匹配字母或数字或下划线或汉字</td></tr><tr><td align="center">\s</td><td align="left">匹配任意的空白符</td></tr><tr><td align="center">\d</td><td align="left">匹配数字</td></tr><tr><td align="center">\b</td><td align="left">匹配单词的开始或结束</td></tr><tr><td align="center">^</td><td align="left">匹配字符串的开始</td></tr><tr><td align="center">$</td><td align="left">匹配字符串的结束</td></tr></tbody></table><p>有了元字符之后，我们就可以利用这些元字符来写一些简单的正则表达式了，<br>比如：</p><ol><li>匹配有abc开头的字符串：</li></ol><pre class=" language-java"><code class="language-java"><span class="token number">1</span>\babc或者<span class="token operator">^</span>abc</code></pre><ol><li>匹配8位数字的QQ号码：</li></ol><pre class=" language-java"><code class="language-java"><span class="token number">1</span><span class="token operator">^</span>\d\d\d\d\d\d\d\d$</code></pre><ol><li>匹配1开头11位数字的手机号码：</li></ol><pre class=" language-java"><code class="language-java"><span class="token number">1</span><span class="token operator">^</span><span class="token number">1</span>\d\d\d\d\d\d\d\d\d\d$</code></pre><h3 id="2-重复限定符"><a href="#2-重复限定符" class="headerlink" title="2. 重复限定符"></a>2. 重复限定符</h3><p>有了元字符就可以写不少的正则表达式了，但细心的你们可能会发现：别人写的正则简洁明了，而不理君写的正则一堆乱七八糟而且重复的元字符组成的。正则没提供办法处理这些重复的元字符吗？</p><p>答案是有的！<br>为了处理这些重复问题，正则表达式中一些重复限定符，把重复部分用合适的限定符替代，下面我们来看一些限定符：</p><table><thead><tr><th align="center">语法</th><th align="left">说明</th></tr></thead><tbody><tr><td align="center">*</td><td align="left">重复零次或更多次</td></tr><tr><td align="center">+</td><td align="left">重复一次或更多次</td></tr><tr><td align="center">?</td><td align="left">重复零次或一次</td></tr><tr><td align="center">{n}</td><td align="left">重复n次</td></tr><tr><td align="center">{n,}</td><td align="left">重复n次或更多次</td></tr><tr><td align="center">{n,m}</td><td align="left">重复n到m次</td></tr></tbody></table><p>有了这些限定符之后，我们就可以对之前的正则表达式进行改造了，比如：</p><ol><li>匹配8位数字的QQ号码：</li></ol><pre class=" language-java"><code class="language-java"><span class="token number">1</span><span class="token operator">^</span>\d<span class="token punctuation">{</span><span class="token number">8</span><span class="token punctuation">}</span>$</code></pre><ol><li>匹配1开头11位数字的手机号码：</li></ol><pre class=" language-java"><code class="language-java"><span class="token number">1</span><span class="token operator">^</span><span class="token number">1</span>\d<span class="token punctuation">{</span><span class="token number">10</span><span class="token punctuation">}</span>$</code></pre><ol><li>匹配银行卡号是14~18位的数字：</li></ol><pre class=" language-java"><code class="language-java"><span class="token number">1</span><span class="token operator">^</span>\d<span class="token punctuation">{</span><span class="token number">14</span><span class="token punctuation">,</span><span class="token number">18</span><span class="token punctuation">}</span>$</code></pre><ol><li>匹配以a开头的，0个或多个b结尾的字符串</li></ol><pre class=" language-java"><code class="language-java"><span class="token number">1</span><span class="token operator">^</span>ab<span class="token operator">*</span>$</code></pre><h3 id="3-分组"><a href="#3-分组" class="headerlink" title="3. 分组"></a>3. 分组</h3><p>从上面的例子（4）中看到，<em>限定符是作用在与他左边最近的一个字符，那么问题来了，如果我想要ab同时被</em>限定那怎么办呢？</p><blockquote><p>正则表达式中用小括号()来做分组，也就是括号中的内容作为一个整体。</p></blockquote><p>因此当我们要匹配多个ab时，我们可以这样<br>如：匹配字符串中包含0到多个ab开头：</p><pre class=" language-java"><code class="language-java"><span class="token number">1</span><span class="token operator">^</span><span class="token punctuation">(</span>ab<span class="token punctuation">)</span><span class="token operator">*</span></code></pre><h3 id="4-转义"><a href="#4-转义" class="headerlink" title="4. 转义"></a>4. 转义</h3><p>我们看到正则表达式用小括号来做分组，那么问题来了：</p><blockquote><p>如果要匹配的字符串中本身就包含小括号，那是不是冲突？应该怎么办？</p></blockquote><p>针对这种情况，正则提供了转义的方式，也就是要把这些元字符、限定符或者关键字转义成普通的字符，做法很简答，就是在要转义的字符前面加个斜杠，也就是\即可。<br>如：要匹配以(ab)开头：</p><pre class=" language-java"><code class="language-java"><span class="token number">1</span><span class="token operator">^</span><span class="token punctuation">(</span>\<span class="token punctuation">(</span>ab\<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token operator">*</span></code></pre><h3 id="5-条件或"><a href="#5-条件或" class="headerlink" title="5. 条件或"></a>5. 条件或</h3><p>回到我们刚才的手机号匹配，我们都知道：国内号码都来自三大网，它们都有属于自己的号段，比如联通有130/131/132/155/156/185/186/145/176等号段，假如让我们匹配一个联通的号码，那按照我们目前所学到的正则，应该无从下手的，因为这里包含了一些并列的条件，也就是“或”，那么在正则中是如何表示“或”的呢？</p><blockquote><p>正则用符号 | 来表示或，也叫做分支条件，当满足正则里的分支条件的任何一种条件时，都会当成是匹配成功。</p></blockquote><p>那么我们就可以用或条件来处理这个问题</p><pre class=" language-java"><code class="language-java"><span class="token number">1</span><span class="token operator">^</span><span class="token punctuation">(</span><span class="token number">130</span><span class="token operator">|</span><span class="token number">131</span><span class="token operator">|</span><span class="token number">132</span><span class="token operator">|</span><span class="token number">155</span><span class="token operator">|</span><span class="token number">156</span><span class="token operator">|</span><span class="token number">185</span><span class="token operator">|</span><span class="token number">186</span><span class="token operator">|</span><span class="token number">145</span><span class="token operator">|</span><span class="token number">176</span><span class="token punctuation">)</span>\d<span class="token punctuation">{</span><span class="token number">8</span><span class="token punctuation">}</span>$</code></pre><h3 id="6-区间"><a href="#6-区间" class="headerlink" title="6. 区间"></a>6. 区间</h3><p>看到上面的例子，是不是看到有什么规律？是不是还有一种想要简化的冲动？<br>实际是有的</p><blockquote><p>正则提供一个元字符中括号 [] 来表示区间条件。</p><ol><li>限定0到9 可以写成[0-9]</li><li>限定A-Z 写成[A-Z]</li><li>限定某些数字 [165]</li></ol></blockquote><p>那上面的正则我们还改成这样：</p><pre class=" language-java"><code class="language-java"><span class="token number">1</span><span class="token operator">^</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token number">13</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token operator">-</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token operator">|</span><span class="token punctuation">(</span><span class="token number">15</span><span class="token punctuation">[</span><span class="token number">56</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token operator">|</span><span class="token punctuation">(</span><span class="token number">18</span><span class="token punctuation">[</span><span class="token number">5</span><span class="token operator">-</span><span class="token number">6</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token operator">|</span><span class="token number">145</span><span class="token operator">|</span><span class="token number">176</span><span class="token punctuation">)</span>\d<span class="token punctuation">{</span><span class="token number">8</span><span class="token punctuation">}</span>$</code></pre><p>好了，正则表达式的基本用法就讲到这里了，其实它还有非常多的知识点以及元字符，我们在此只列举了部分元字符和语法来讲，旨在给那些不懂正则或者想学正则但有看不下去文档的人做一个快速入门级的教程，看完本教程，即使你不能写出高大上的正则，至少也能写一些简单的正则或者看得懂别人写的正则了，如果需要进阶学习，那就靠各位好好修炼啦。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 正则 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="2021/06/03/hello-world/"/>
      <url>2021/06/03/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre class=" language-bash"><code class="language-bash">$ hexo new <span class="token string">"My New Post"</span></code></pre><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre class=" language-bash"><code class="language-bash">$ hexo server</code></pre><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre class=" language-bash"><code class="language-bash">$ hexo generate</code></pre><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre class=" language-bash"><code class="language-bash">$ hexo deploy</code></pre><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      <categories>
          
          <category> 其他 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>股债平衡策略改进之：波动率决定仓位</title>
      <link href="2021/06/03/gu-zhai-ping-heng-ce-lue-gai-jin-zhi-bo-dong-lu-jue-ding-cang-wei/"/>
      <url>2021/06/03/gu-zhai-ping-heng-ce-lue-gai-jin-zhi-bo-dong-lu-jue-ding-cang-wei/</url>
      
        <content type="html"><![CDATA[<p>我们提出了基于风险暴露平价的股债平衡策略。</p><p>这个策略本质上，<strong>是用波动率大小来决定股票资产的仓位，即波动率越大时股票资产仓位越小，反之，波动率越小时股票资产仓位越大。</strong></p><p><strong>基于波动率分位数的股债平衡策略</strong>，也是根据波动率大小来决定股票资产的仓位，**它的核心逻辑是股票资产仓位等于(1-波动率分位数)**，依然是股票资产仓位和波动率大小成反比。</p><p>波动率分位数表示的是股票指数当前的波动率水平，在历史区间所处的高低水平位置。</p><p>假设波动率分位数为20%，就表示历史上的波动率只有20%的时候比当期的波动率还要低。</p><p>波动率的度量仍然采用标准差方法。</p><p>与风险暴露平价方法相比，波动率分位数方法有一个好处，就是<strong>不用主观的去决定初期股票资产的目标仓位取值，初期股票资产的目标仓位大小对后续策略的运行也没有影响</strong>，因为对基于波动率分位数的股债平衡策略而言，每一期的股票资产目标仓位都是客观的由波动率分位数所决定的。</p><p>接下来，我们以量化回测的方法来对基于波动率分位数的股债平衡策略的历史表现进行详细分析。</p><p><strong>【交易标的】</strong></p><p>股票：<a href="https://xueqiu.com/S/SH000300?from=status_stock_match">沪深300</a>指数(000300.SH)</p><p>债券：中证全债(H11001.CSI)</p><p><strong>【测试时间】</strong></p><p>2013年1月1日 ~ 2020年9月30日</p><p><strong>【交易逻辑】</strong></p><p>当波动率分位数为(1-q)%时, 股票的目标仓位为q%，债券的目标仓位为(1-q)%。</p><p>(1)当股票的实际仓位s% 减去 目标仓位q% 大于10%时，触发再平衡调仓，卖出(s-q)%仓位的股票，并买入债券。</p><p>(2)当股票的目标仓位q% 减去 实际仓位s% 大于10%时，触发再平衡调仓，买入(q-s)%仓位的股票部分，并卖出债券。</p><p>分位数根据最近5年数据计算</p><p><strong>【参数设置】</strong></p><p>本策略只含有1个参数，即计算标准差时所采用的历史数据长度N，默认N=30。</p><p>ETF交易成本取万分之五，不考虑现金的利息收益。</p><p><strong>【测试结果】</strong></p><p><em>为方便说明，我们记目标股债比例为50%:50%的传统股债平衡策略为BS策略，记基于波动率分位数的股债平衡策略为BS_VR策略。</em></p><p><img src="https://xqimg.imedao.com/17626428e25ea493fec18bbb.png!800.jpg" alt="img"></p><p>从收益结果看，基于波动率分位数的股债平衡策略，也就是BS_VR策略，年化收益为10.6%，不仅高于普通的股债平衡策略，也高于<a href="https://xueqiu.com/S/SH000300?from=status_stock_match">沪深300</a>指数的年化涨幅。</p><p>另外，BS_VR策略的历史最大回撤为20.79%，发生在2013年的熊末期间，此时由于市场波动率较小，所以股票资产仓位维持在高位，策略净值走势和股价走势很接近。</p><p>抛开这段时间不谈，策略在其他时间段的的最大回撤并不高。</p><p>BS_VR策略的历史最大回撤稍微低于BS策略，大幅低于<a href="https://xueqiu.com/S/SH000300?from=status_stock_match">沪深300</a>指数自身的历史最大回撤。</p><p>BS_VR策略的<strong>历史净值走势走势很稳健，波动远小于沪深300指数自身，这是用波动率大小来决定股票仓位这类方法的一个普遍优点。</strong></p><p>总的来说，根据波动率分位数来决定股票仓位，也是一种有效的方法，首先它能大幅度的控制投资风险，其次也能在一定程度上提高投资收益。</p><p>当然，这个收益提高的幅度肯定是不够的，因为<strong>本策略所用方法的主要目的还是在于控制风险，而并非提高收益</strong>，要提高收益，我们还得采用其他法子，这个我们在后面的文章里会陆续讲到，欢迎保持关注。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 理财 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>股债平衡策略改进之：风险暴露平价决定仓位</title>
      <link href="2021/06/03/gu-zhai-ping-heng-ce-lue-gai-jin-zhi-feng-xian-bao-lu-ping-jie-jue-ding-cang-wei/"/>
      <url>2021/06/03/gu-zhai-ping-heng-ce-lue-gai-jin-zhi-feng-xian-bao-lu-ping-jie-jue-ding-cang-wei/</url>
      
        <content type="html"><![CDATA[<p>同样持有10万元市值的股票，在2015年时所面临的风险和现在(2019年)是截然不同的。</p><p>因为2015年时大量的股票经常动不动就是涨停或跌停，甚至<a href="https://xueqiu.com/S/SH000300?from=status_stock_match">沪深300</a>、<a href="https://xueqiu.com/S/SH000905?from=status_stock_match">中证500</a>这种宽基指数经常都能涨跌百分之五六，而现在，一般股票很少能涨停或跌停，沪深300指数就更不用说了，涨跌超过2%，就可以说是大涨或大跌了。</p><p>造成这种现象的原因，是因为<strong>2015年时A股波动率大，而现在波动率小。</strong></p><p><strong>所谓波动率，就是指股票价格波动的风险大小。</strong></p><p><strong>股票市值乘以波动率，就是风险暴露水平。</strong></p><p><strong>如果前后两个时点，股票资产的风险暴露水平相等，我们就说是风险暴露平价。</strong></p><p>举个例子，假设在2015年牛市高位的某天，股票(<a href="https://xueqiu.com/S/SH000300?from=status_stock_match">沪深300</a>)资产为10万元，沪深300指数的波动率为4.5%，那么此时股票资产的风险暴露水平为4500元(=10万元×4.5%)。</p><p>再假设2019年的某天，股票资产为30万元，<a href="https://xueqiu.com/S/SH000300?from=status_stock_match">沪深300</a>指数的波动率为1.5%，此时股票资产的风险暴露水平同样为4500元(=30万元×1.5%)，我们就说这两个时刻是<strong>风险暴露平价</strong>的。</p><p><strong>基于风险暴露平价的股债平衡策略，就是通过调整股票仓位的大小，使股债组合中的股票资产保持风险暴露水平不变</strong>，<strong>即：</strong></p><p>总资产(第t期) × 股票仓位(第t期) × 波动率(第t期) <strong>=</strong> 总资产(第t-1期) × 股票仓位(第t-1期) × 波动率(第t-1期)</p><p>根据上述逻辑，初期股票仓位所代表的风险水平在很大程度上是策略整个运行期间的风险水平基准，如果初期股票仓位设置的高，那么策略在运行期间的风险水平就会高，当然，与之相应的期望收益也会更高。</p><p><strong>初期股票仓位的大小在很大程度上决定了策略的收益风险水平。</strong></p><p>我们可以根据自身的风险偏好来主观设置初期股票仓位，如果是风险厌恶投资者，可以设置较低的初期股票仓位，比如20%，如果是风险偏好的投资者，可以设置较高的初期股票仓位，比如80%，如果是风险中性投资者，则可以设置为50%。</p><p>此外，我们也可以根据市场情况客观的来决定初期股票仓位的大小，比如根据市场估值来决定初期股票仓位就是一个很合理的方法，如果初期时股票资产的估值较高，那么就设置较高的初期股票仓位，反之就设置较低的股票仓位。</p><p>具体操作时，可令<strong>初期股票仓位等于(1-(PE分位数+PB分位数)/2)。</strong></p><p>接下来，我们以量化回测的方法来对基于风险暴露平价的股债平衡策略的历史表现进行详细分析。</p><p><strong>【交易标的】</strong></p><p>股票：<a href="https://xueqiu.com/S/SH000300?from=status_stock_match">沪深300</a>指数(000300.SH)</p><p>债券：中证全债(H11001.CSI)</p><p><strong>【测试时间】</strong></p><p>2013年1月1日 ~ 2020年9月30日</p><p><strong>【交易逻辑】</strong></p><p>第t期的目标股票仓位q% = 总资产(第t-1期) × 股票仓位(第t-1期) × 波动率(第t-1期) / {总资产(第t期) × 波动率(第t期)}</p><p>(1)当股票的实际仓位s% 减去 目标仓位q% 大于10%时，触发再平衡调仓，卖出(s-q)%仓位的股票，并买入债券。</p><p>(2)当股票的目标仓位q% 减去 实际仓位s% 大于10%时，触发再平衡调仓，买入(q-s)%仓位的股票部分，并卖出债券。</p><p><strong>【参数设置】</strong></p><p>本策略只含有1个参数，即计算标准差时所采用的历史数据长度N，默认N=30。</p><p>ETF交易成本取万分之五，不考虑现金的利息收益。</p><p><strong>【测试结果】</strong></p><p><img src="https://xqimg.imedao.com/175fd831e5c12f93fb2dbb60.png!800.jpg" alt="img"></p><p><em>为方便说明，我们记目标股债比例为50%:50%的传统股债平衡策略为BS策略，记基于风险暴露平价的股债平衡策略为BS_REP策略，当初期股票仓位分别取20%、50%和80%时，分别记为BS_REP_20、BS_REP_50、BS_REP_80，当初期股票仓位由估值分位数决定时，记为BS_REP_V。</em></p><p>从收益结果看，各策略的最大回撤和<a href="https://xueqiu.com/S/SH000300?from=status_stock_match">沪深300</a>指数相比有着明显的缩小，当初始股票仓位高于50%时，策略的收益就会高于沪深300指数，也即收益和风险表现都优于沪深300指数自身，从这点看，基于风险暴露平价来决定股票仓位是有作用的。</p><p><img src="https://xqimg.imedao.com/175fd831e6213a53f997bedc.png!800.jpg" alt="img"></p><p>上图是初始股票仓位是50%的策略的净值走势，总体来说，走的很稳健，投资风险不高，但是投资收益也不算高，说这个方法的作用主要在于控制风险，追求收益的能力还不强，要想达到跟高的投资收益，我们还要想别的办法。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 理财 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>股债平衡策略改进之：估值决定仓位</title>
      <link href="2021/06/03/gu-zhai-ping-heng-ce-lue-gai-jin-zhi-gu-zhi-jue-ding-cang-wei/"/>
      <url>2021/06/03/gu-zhai-ping-heng-ce-lue-gai-jin-zhi-gu-zhi-jue-ding-cang-wei/</url>
      
        <content type="html"><![CDATA[<p>对股债平衡策略而言，考虑股票估值低时，仓位高一点，股票估值高时，仓位低一点，符合我们对投资的一般理解，是一个合乎逻辑的改进方向。</p><p>因此，我们来讨论如何利用估值逻辑来对股债平衡策略进行改进。</p><p>我们面临的第一个问题就是：*<em>如何判断股票估值的高低**</em>(注:只讨论股票指数)*。</p><p>首先，我们考虑用估值的绝对水平高低来判断，比如PE小于10倍(盈利收益率1/PE=10%)时为低估，PE大于20倍时(盈利收益率1/PE=5%)算高估。</p><p>但是，这样做有个很严重的问题，就是<strong>低估和高估的临界数值怎么取</strong>。</p><p><strong>同一指数在不同时期的取值差异很大</strong>，比如<a href="https://xueqiu.com/S/SH000300?from=status_stock_match">沪深300</a>，20倍PE放现在可能是难以企及的天花板，但放10年前就只是估值中枢而已。</p><p><strong>不同指数的取值差异更是会非常大</strong>，比如对<a href="https://xueqiu.com/S/SH000905?from=status_stock_match">中证500</a>，20倍PE就是一个很低的值，10倍的PE也许在可预见的范围内都看不到，如果涉及不同行业指数和主题指数，更是没有统一判断标准，只能主观一个一个去判断。</p><p><strong>如果不从后视镜角度去看，相信一般人很难判断出各指数的高低估值区间。</strong></p><p>总之，这个方法操作起来不严谨，也不具有通用性，我们先放弃掉。</p><p>接下来，我们从指数的相对估值水平考虑，也就是分位数，比如，当PE(或者PB)分位数为10%时，可以认为股票是低估的，股票目标仓位取90%，当其分位数为90%时，可以认为股票是高估的，股票目标仓位取10%，即<strong>股票目标仓位 = (1-PE分位数)。</strong></p><p>这个方法通用性很好，因此，我采用这个方法来看看效果。</p><p><strong>【交易标的】</strong></p><p>股票：<a href="https://xueqiu.com/S/SH000300?from=status_stock_match">沪深300</a>指数(000300.SH)</p><p>债券：中证全债(H11001.CSI)</p><p><strong>【测试时间】</strong></p><p>2013年1月1日 ~ 2020年9月30日</p><p><strong>【交易逻辑】</strong></p><p>当PE或PB分位数为(1-q)%时, 股票的目标仓位为q%，债券的目标仓位为(1-q)%。</p><p>(1)当股票的实际仓位s% 减去 目标仓位q% 大于10%时，触发再平衡调仓，卖出(s-q)仓位的股票，并买入债券。</p><p>(2)当股票的目标仓位q% 减去 实际仓位s% 大于10%时，触发再平衡调仓，买入(q-s)%仓位的股票部分，并卖出债券。</p><p>分位数根据最近5年数据计算</p><p><strong>【参数设置】</strong></p><p>本策略无其他参数。</p><p>ETF交易成本取万分之五，不考虑现金的利息收益。</p><p><strong>【测试结果】</strong></p><p>下表中，“BS_PE”为我们所要测试的基于市盈率分位数的股债平衡策略，“股债_50%：50%”是目标股债比例为50%：50%的传统股债平衡策略。</p><p><img src="https://xqimg.imedao.com/175f8b4ce182a13e3f5f820e.png!800.jpg" alt="img"></p><p>从策略净值走势看，基于市盈率分位数的股债平衡策略(BS_PE)总体来说比较稳健，在多数时间内净值均保持增长。</p><p>BS_PE策略的历史年化收益分别为9.31%，高于传统股债平衡策略(50%：50%)的年化收益，也高于<a href="https://xueqiu.com/S/SH000300?from=status_stock_match">沪深300</a>指数自身的年化涨幅。</p><p>同时，BS_PE策略的最大回撤也比传统股债平衡策略也稍小一些，从而它有着最高的收益风险比。</p><p>另外，我们也来看看用PB分位数来决定股票仓位的股债平衡策略的效果：</p><p><img src="https://xqimg.imedao.com/175f8b4cec02a0a53fec0db4.png!800.jpg" alt="img"></p><p> 总的来说，PB分位数的效果比PE分位数的效果还更好一些，这进一步说明用估值指标来决定股票仓位是有效的。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 理财 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>股债平衡策略改进之：基于股价涨跌幅调仓</title>
      <link href="2021/06/03/gu-zhai-ping-heng-ce-lue-gai-jin-zhi-ji-yu-gu-jie-zhang-die-fu-diao-cang/"/>
      <url>2021/06/03/gu-zhai-ping-heng-ce-lue-gai-jin-zhi-ji-yu-gu-jie-zhang-die-fu-diao-cang/</url>
      
        <content type="html"><![CDATA[<p>不同目标股债比例下，触发调仓所需的股价涨幅相差很大，调仓阈值的设置不具有普适性，也就是说根据股票仓位变化来进行调仓不是一个合理的做法。</p><p>比如，对90%:10%股债平衡策略来说，需要股票上涨111.1%才能使股票仓位上升到95%从而触发调仓，这显然太难了；</p><p>而对50%:50%股债平衡策略来说，只需股票上涨22.2%就能使股票仓位上升到55%从而触发调仓，比较合理了。</p><p>所以，这里我们考虑<strong>基于股价涨跌幅来进行再平衡调仓</strong>。</p><p>最直接的想法，就是<strong>固定股票价格上涨或下跌一定比例r%就触发再平衡调仓</strong>，这样，不同目标仓位的股债平衡策略的调仓信号发生时点都会是一致的。上涨r%就卖一部分股票，下跌r%就买一部分股票，等于是在震荡区间拿出一部分仓位来做高抛低吸。</p><p>接下来的问题是r%怎么取，如果取得太小(比如5%)，交易会很频繁，取得太大(比如50%)，又很难达到。</p><p>有个很自然的想法，就是根据股票的波动率来取，我们以<a href="https://xueqiu.com/S/SH000300?from=status_stock_match">沪深300</a>指数为例，<strong>用年化标准差(最近1年数据计算)来度量它的年化波动率</strong>，走势如下：</p><p>可以看到，<a href="https://xueqiu.com/S/SH000300?from=status_stock_match">沪深300</a>的年化波动率基本上在15-25%之间，中枢大概在20%左右。</p><p>年化波动率为20%，它的直观意思就是，<a href="https://xueqiu.com/S/SH000300?from=status_stock_match">沪深300</a>指数一年期的涨跌幅大概率(约68.3%)不会超过20%，这和我们的直观感受应该是比较一致的。</p><p><strong>一般性的，我们可以令r%等于股票的年化波动率。</strong></p><p>但为了大家实盘时的方便，对<a href="https://xueqiu.com/S/SH000300?from=status_stock_match">沪深300</a>指数，我们可以直接设置r%为20%，因为在可预见的未来，沪深300的年化波动率很难大幅脱离15-25%这个区间。</p><p>接下来，我们对上述说的基于股价涨跌幅进行再平衡调仓的股债平衡策略进行量化回测，来看看它在历史上的业绩表现如何，有何特征。</p><p><strong>【交易标的】</strong></p><p>股票：<a href="https://xueqiu.com/S/SH000300?from=status_stock_match">沪深300</a>指数(000300.SH)</p><p>债券：中证全债(H11001.CSI)</p><p><strong>【测试时间】</strong></p><p>2013年1月1日 ~ 2020年9月30日</p><p><strong>【交易逻辑】</strong></p><p>以持有a%仓位的<a href="https://xueqiu.com/S/SH000300?from=status_stock_match">沪深300</a>指数和(1-a)%仓位的中证全债为目标，且：</p><p>(1)当<a href="https://xueqiu.com/S/SH000300?from=status_stock_match">沪深300</a>指数的涨幅(相较于上次调仓时价格)大于r%时，卖出部分股票，使沪深300指数的仓位重新回到a%；</p><p>(2)当<a href="https://xueqiu.com/S/SH000300?from=status_stock_match">沪深300</a>指数的跌幅(相较于上次调仓时价格)大于r%时，买入部分股票，使沪深300指数的仓位重新回到a%；</p><p><strong>【参数设置】</strong></p><p>目标股票仓位a% = 0%, 10%，20%， 30%,…90%,100%</p><p>股票涨跌幅r% = 20%</p><p>另外，ETF交易成本取万分之五，不考虑现金的利息收益。</p><p><strong>【测试结果】</strong></p><p><img src="https://xqimg.imedao.com/175e382e42124b263fee57c8.png!800.jpg" alt="img"></p><p>上表是不同目标股债比例下，基于股价涨跌幅进行再平衡调仓的传统股债平衡策略的业绩表现，这里的股价涨跌幅阈值r%取20%。</p><p>通过分析，我们得出以下结论：</p><p>首先，<strong>由于策略是根据股价涨跌幅来进行调仓的，所以不同目标股债比例的交易时点是完全一致的，交易次数和交易周期也完全一致。</strong></p><p>当我们设置股价变化阈值为20%时，策略在测试期范围内的总交易次数为11次，平均171.4个交易日调仓一次，参考传统股债平衡策略的情况，这是一个可以接受的结果。</p><p>因此，股价变化阈值取20%是合理的，不管我们选择何种目标股债比例，都可以这么设置，也就是说，这是一个通用的做法。</p><p>其次，<strong>基于股价涨跌幅的股债平衡策略的业绩表现总体上和传统股债平衡策略差不多，没有本质区别，说明根据股价涨跌幅来做再平衡调仓不能提高策略的业绩表现。</strong></p><p>因此，我们后面再考虑别的改进方法。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 理财 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>深度解析：传统股债平衡策略的优缺点</title>
      <link href="2021/06/03/shen-du-jie-xi-chuan-tong-gu-zhai-ping-heng-ce-lue-de-you-que-dian/"/>
      <url>2021/06/03/shen-du-jie-xi-chuan-tong-gu-zhai-ping-heng-ce-lue-de-you-que-dian/</url>
      
        <content type="html"><![CDATA[<p>们介绍了股债平衡策略的基本思想与逻辑，并提出了一些对传统股债平衡策略进行改进的方向。</p><p>传统股债平衡策略就是格雷厄姆在《聪明的投资者》一书中所提出的股债仓位50%:50%平衡策略，当股票仓位偏离理论仓位达到一定程度时(比如5%)进行再平衡调仓。</p><p>当然，我们可以不用局限于股票仓位是50%，也可以是20%、30%，或者70%、90%。具体股票仓位取多少，主要看投资者自己的风险偏好，风险偏好低的可以股票少一点，债券多一点，反之，风险偏好高的可以股票多一点，债券少一点。</p><p>不过，我们也应该看看不同的股债仓位比例取法，其投资效果是否有本质的区别。</p><p>接下来，我们先来看看传统股债平衡策略的历史业绩表现如何，有和特征，然后再考虑如何对传统股债平衡策略进行改进，提升投资效果。</p><p><strong>【交易标的】</strong></p><p>股票：<a href="https://xueqiu.com/S/SH000300?from=status_stock_match">沪深300</a>指数(000300.SH)</p><p>债券：中证全债(H11001.CSI)</p><p><strong>【测试时间】</strong></p><p>2013年1月1日 ~ 2020年9月30日</p><p><strong>【交易逻辑】</strong></p><p>以持有a%仓位的<a href="https://xueqiu.com/S/SH000300?from=status_stock_match">沪深300</a>指数和(1-a)%仓位的中证全债为目标股债仓位，当股票上涨或下跌，导致实际仓位偏离目标仓位一定阈值时，触发再平衡调仓，使股票的实际仓位重新回到目标仓位，即：</p><p>(1)当<a href="https://xueqiu.com/S/SH000300?from=status_stock_match">沪深300</a>指数的实际仓位大于(a%+b%)时，卖出b%仓位的股票，买入b%仓位的债券；</p><p>(2)当<a href="https://xueqiu.com/S/SH000300?from=status_stock_match">沪深300</a>指数的实际仓位小于(a%-b%)时，卖出b%仓位的债券，买入b%仓位的股票；</p><p><strong>【参数设置】</strong></p><p>目标股票仓位a% = 0%, 10%，20%, … ,90%,100%</p><p>调仓阈值b% = 5%</p><p>另外，ETF交易成本取万分之五，不考虑现金的利息收益。</p><p><strong>【测试结果】</strong></p><p>上表是不同比例下的传统股债平衡策略的业绩表现，通过分析，我们得出以下结论：</p><p><strong>(1)**虽然股债平衡策略的收益大概率没有<a href="https://xueqiu.com/S/SH000300?from=status_stock_match">沪深300</a>指数高(特别是在长期)，但股债平衡策略的最大回撤基本上要比沪深300指数小很多，</strong>综合收益风险比来看，股债平衡策略是明显优于直接买入持有沪深300指数的**。</p><p>具体看数据，经典的50%:50%股债平衡策略的期望年化收益为7.07%，最大回撤为23.50%，收益风险比为0.3，而<a href="https://xueqiu.com/S/SH000300?from=status_stock_match">沪深300</a>指数买入持有策略的收益风险比只有0.17。</p><p>下图是目标股债比例50%:50%的传统股债平衡策略历史净值走势，可以看到，<strong>策略净值走势的稳定性明显要强于沪深300指数自身的价格走势。</strong></p><p><img src="https://xqimg.imedao.com/175def1cf6322c023fd7965e.png!800.jpg" alt="img"></p><p>**(2)**我们还发现有个问题，就是10%:90%股债平衡策略和90%:10%股债平衡策略的交易次数太少了，说明调仓阈值b%取的有问题，策略的实际操作意义较小，对行情的买卖判断太少了，显得很消极。</p><p>因为，总不至于恰好买卖一两次就正好买在底部区域，卖在最高区域。从统计学角度讲，当交易次数太少时，不管结果是好还是坏，都说明不了什么问题。</p><p>我们以目标股债比例90%:10%为例，来看看为什么它的交易次数这么少。</p><p>假如初始时，股票资产的市值为90元，债券资产市值10元，两者仓位比例为90%:10%。假设债券价格不变，以股票资产市值向上的情况为例，当股票价格上涨x%之后，股票仓位从90%变成95%，触发再平衡调仓，这时候：</p><p><img src="https://xqimg.imedao.com/175def1cf4422c5a3fe18588.png!800.jpg" alt="img"></p><p>也就是说，股票价格需要上涨111.1%才会触发再平衡调仓，显然，这非常的难，特别对<a href="https://xueqiu.com/S/SH000300?from=status_stock_match">沪深300</a>指数这种规模指数，只要在大牛市时才可能有这么高的涨幅，这就不难理解为什么策略在历史上只发生1次交易了。</p><p>各目标股债比例下策略触发调仓所需股票涨幅见下表：</p><p><img src="https://xqimg.imedao.com/175def1cf3d22c013fe263d5.png!800.jpg" alt="img"></p><p>以<a href="https://xueqiu.com/S/SH000300?from=status_stock_match">沪深300</a>指数的波动率，上涨20~30%还不算是很难，但要上涨50%以上，就不容易了，基本要遇到大牛市或者连续数年的慢牛才行。</p><p>此外，不同目标股债比例下，触发调仓所需的股价涨幅相差很大，这说明，调仓阈值的设置不具有普适性，我们应该考虑其他办法来设置目标股债比例。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 理财 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>行业轮动策略：从动量指标说起</title>
      <link href="2021/06/03/xing-ye-lun-dong-ce-lue-cong-dong-liang-zhi-biao-shuo-qi/"/>
      <url>2021/06/03/xing-ye-lun-dong-ce-lue-cong-dong-liang-zhi-biao-shuo-qi/</url>
      
        <content type="html"><![CDATA[<p>在经济周期各个阶段，不同的行业所处的经营环境、发展形势是不完全一致的，会出现有些行业发展的很好，而有些行业发展的不好的现象，也即<strong>行业之间的发展是不同步的，这是行业轮动的基本面逻辑所在。</strong></p><p><strong>行业轮动策略</strong>，就是<strong>利用某种方法识别出每个阶段的强势行业，然后轮换配置这些行业</strong>，显然，如果我们能抓住每个时间段的强势行业，必然可以大幅提高投资收益。</p><p>至于怎么识别出每个时间段内最强的行业，最通用、最有效的的方法依然是利用<strong>动量指标。</strong></p><p>所谓动量指标，其实就是股价的N期涨跌幅，1个月动量就是最近1个月股价的涨跌幅，3个月动量就是最近3个月股价的涨跌幅。</p><p><strong>一个行业，不管它是因为什么原因强势，最终必然要体现在股价的强势上，股价越强势的行业，它的股价涨跌幅自然越高，也即动量因子最大。</strong></p><p>所以，我们通过持有动量指标指最高的行业指数，就可以捕捉到各个阶段股价最强势的行业指数，并希望这种趋势在未来能继续延续，这就是用动量指标来做行业轮动策略的核心思想。</p><p>下面我们以量化回测的方法来看看这个策略的历史表现如何。</p><p><strong>【交易标的】</strong></p><p>轮动标的行业指数如下：</p><p><strong>【测试时间】</strong></p><p>2013年1月1日～2020年9月30日</p><p><strong>【交易逻辑】</strong></p><p>买入并持有指数池中动量排名前两位的指数，并在动量排名发生变化时进行调仓。</p><p><strong>【参数设置】</strong></p><p>本策略只含有1个参数，即动量指标的周期参数N，默认取N=20。</p><p>另外，ETF交易成本取万分之五，不考虑现金的利息收益。</p><p><strong>【测试结果】</strong></p><p>下表是行业轮动策略的业绩表现：</p><p><img src="https://xqimg.imedao.com/175b5319ec01457f3fdfdf57.png!800.jpg" alt="img"></p><p>注:“B&amp;H策略”为买入并持有所有指数的等权组合</p><p><img src="https://xqimg.imedao.com/175b5319eb7145733fea6a74.png!800.jpg" alt="img"></p><p>图中黑线是行业轮动策略的净值走势，灰线是各指数买入并持有策略的净值走势，</p><p>行业轮动策略的年化收益为14.82%，稍高于买入并持有策略。轮动策略由于可以切换配置阶段占优板块，在收益方面有所表现是很正常的，但是这里策略收益的提升幅度还不够。</p><p>不过我们这里也只采用最基础的动量轮动策略，如果加入正动量过滤条件使其可以躲避全面熊市行情，加入缓冲条件来降低无谓的频繁交易，还可以有效提高策略收益，具体我们后面的文章再说。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 理财 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>在风格轮动策略中，如何避开全面熊市行情？</title>
      <link href="2021/06/03/zai-feng-ge-lun-dong-ce-lue-zhong-ru-he-bi-kai-quan-mian-xiong-shi-xing-qing/"/>
      <url>2021/06/03/zai-feng-ge-lun-dong-ce-lue-zhong-ru-he-bi-kai-quan-mian-xiong-shi-xing-qing/</url>
      
        <content type="html"><![CDATA[<p>我们测试了<strong>基于动量指标的大小盘风格轮动策略</strong>的历史业绩效果。</p><p>该策略的核心交易逻辑是买入并持有指数池中动量排名第一的指数，并在动量排名发生变化时进行调仓。这里的动量指标，就是股价的N日涨跌幅。</p><p>该策略可以利用大小盘股强势阶段在时间上的错位，不停地切换配置阶段占优的一方，必然能大幅提升投资收益。</p><p>该策略在测试期范围内录得了年化22%+的收益表现，但是遗憾的是它的历史回撤太大，高达56%，和指数自身的历史最大回撤差不多，这个级别的历史最大回撤显然是无法让人接受。</p><p>之所以会有这么高的回撤，是<strong>因为在全面熊市时很有可能所有指数的动量都为负，而策略在这个时候仍然会持有动量排名第一的指数，也即在全面下跌行情时仍会持续满仓股票资产</strong>，所以才有这么大级别的回撤。</p><p>因此，我们要考虑做些改进，给策略添加一个过滤条件，使其可以避开明显的全面熊市行情。</p><p>我们先考虑了正动量过滤方法，即要求持仓指数不仅动量排名得第一，而且动量还必须为正，经过历史测试分析，我们发现效果挺好，策略的效果有明显改进，详见文章：《<a href="http://mp.weixin.qq.com/s?__biz=MzA3Mzg4MjQwNg==&amp;mid=2247486474&amp;idx=1&amp;sn=13eba843f2b0c8b5ba45e17a81c43ca9&amp;chksm=9f090243a87e8b5596da4b61c4f8ffbd7b08259fe1c747e6144ad436823a1d913b5a2a9bbd19&amp;scene=21#wechat_redirect">年化收益28%+！基于动量指标的大小盘风格轮动策略</a>》。</p><p>还有一种很常见的过滤方法，就是利用均线，<strong>要求持仓指数必须同时满足股价位于均线之上的条件</strong>。</p><p>下面我们用量化回测的方法来看看加入均线过滤条件后策略的效果如何。</p><p><strong>【交易标的】</strong></p><p>我们以<a href="https://xueqiu.com/S/SH000300?from=status_stock_match">沪深300</a>指数作为大盘股的代理变量，以创业板作为小盘股的代理变量，交易标的指数如下：</p><p><strong>【测试时间】</strong></p><p>2013年1月1日～2020年9月30日</p><p><strong>【交易逻辑】</strong></p><p>买入并持有指数池中动量排名第一且股价位于均线之上的指数。当持仓指数的动量排名不是第一或者股价跌破了均线时卖出，并买入新的符合上述买入条件的指数，如果所有指数都不符合买入条件，则不持有任何指数。</p><p><strong>【参数设置】</strong></p><p>本策略只含有2个参数，即动量指标的周期参数N和均线的周期参数M，默认取N=20、M=40。</p><p><strong>【测试结果】</strong></p><p>下表是风格轮动策略，以及分别加入动量过滤条件和均线过滤条件之后的业绩表现：</p><p><img src="https://xqimg.imedao.com/175afee8f55120ed3fe720e1.png!800.jpg" alt="img"></p><p><em>注:“B&amp;H策略”为买入并持有所有指数的等权组合</em></p><p><img src="https://xqimg.imedao.com/175afee8ef011ec43febca5f.png!800.jpg" alt="img"></p><p>图中，黑色粗线是风格轮动策略的历史净值走势，虚线是B&amp;H策略的历史净值走势。红线是<a href="https://xueqiu.com/S/SH000300?from=status_stock_match">沪深300</a>指数，红色线段表示策略此时持有沪深300，绿色是创业板。</p><p>加入均线过滤条件后，策略的历史年化收益和原有的风格轮动策略相比，变化不大，但是最大回撤有一定程度的减小，说明加入均线过滤条件也是有一定的效果的，</p><p>但是，均线过滤的效果不如正动量过滤的效果，而且均线过滤的方法会额外增加一个策略参数。对于这个参数如何设置，我们并没有经典的做法，只是从逻辑上来说，均线的参数应该大于动量的参数，这样可以使我们在均线所反应的长期趋势下进行更为短期的动量轮动交易。</p><p>总的来说，当我们在风格轮动策略中需要过滤全面熊市行情时，建议优先使用正动量过滤方法。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 理财 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>年化收益28%+！基于动量指标的大小盘风格轮动策略</title>
      <link href="2021/06/03/nian-hua-shou-yi-28-ji-yu-dong-liang-zhi-biao-de-da-xiao-pan-feng-ge-lun-dong-ce-lue/"/>
      <url>2021/06/03/nian-hua-shou-yi-28-ji-yu-dong-liang-zhi-biao-de-da-xiao-pan-feng-ge-lun-dong-ce-lue/</url>
      
        <content type="html"><![CDATA[<p>，我们测试了<strong>基于动量指标的大小盘风格轮动策略</strong>的历史业绩效果。</p><p>该策略的核心交易逻辑是买入并持有指数池中动量排名第一的指数，并在动量排名发生变化时进行调仓。这里的动量指标，就是股价的N日涨跌幅。</p><p>该策略可以利用大小盘股强势阶段在时间上的错位，不停地切换配置阶段占优的一方，必然能大幅提升投资收益。</p><p>该策略在测试期范围内录得了年化22%+的收益表现，但是遗憾的是它的历史回撤太大，高达56%，和指数自身的历史最大回撤差不多，这个级别的历史最大回撤显然是无法让人接受。</p><p>之所以会有这么高的回撤，是<strong>因为在全面熊市时很有可能所有指数的动量都为负，而策略在这个时候仍然会持有动量排名第一的指数，也即在全面下跌行情时仍会持续满仓股票资产</strong>，所以才有这么大级别的回撤。</p><p>这里，我们通过添加一个过滤条件对策略进行改进，可以让上述策略在较大程度上躲避全面熊市行情，即<strong>要求持仓指数的动量必须大于0，即使该指数现在的动量值在所有指数中是最大的</strong>，如果所有指数的动量都不大于0，那就空仓。</p><p>下面我们以量化回测的方法来看看加入上述过滤条件改进后的策略效果如何。</p><p><strong>【交易标的】</strong></p><p>我们以<a href="https://xueqiu.com/S/SH000300?from=status_stock_match">沪深300</a>指数作为大盘股的代理变量，以创业板作为小盘股的代理变量，交易标的指数如下：</p><p><strong>【测试时间】</strong></p><p>2013年1月1日～2020年9月30日</p><p><strong>【交易逻辑】</strong></p><p>买入并持有指数池中动量排名第一且动量大于0的指数，如果所有指数的动量均不大于0则不持有任何指数，当动量排名发生变化时进行调仓。</p><p><strong>【参数设置】</strong></p><p>本策略只含有1个参数，即动量指标的周期参数N，默认取N=20。</p><p>另外，ETF交易成本取万分之五，不考虑现金的利息收益。</p><p><strong>【测试结果】</strong></p><p>下表是风格轮动策略及加入过滤条件改进后的业绩表现：</p><p><img src="https://xqimg.imedao.com/175ab8c3da8105c83fde9622.png!800.jpg" alt="img"></p><p>注:“B&amp;H策略”为买入并持有所有指数的等权组合</p><p><img src="https://xqimg.imedao.com/175ab8c3dd9105c93fb354ec.png!800.jpg" alt="img"></p><p>图中，黑色粗线是风格轮动策略的历史净值走势，虚线是B&amp;H策略的历史净值走势。红线是<a href="https://xueqiu.com/S/SH000300?from=status_stock_match">沪深300</a>指数，红色线段表示策略此时持有沪深300，绿色是创业板。</p><p>加入过滤条件后，策略的业绩表现得到了质的提升，特别是风险控制方面，改进前的策略可以说是毫无风险控制能力，它在历史上的最大回撤高达56%，而改进之后的策略最大回撤大幅将至了28%。</p><p>收益方面，改进后策略的年化收益达到了28.7%，这是一个很优秀的收益水平，不但比年化13.8%的B&amp;H策略高很多，也明显高于改进前策略的年化收益。</p><p>也就是说，加入过滤条件之后，策略追求收益和控制风险的能力都有显著提升，其收益风险比也达到了1.02，超过了我们的合格标准1.0。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 理财 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>年化20%+！一个可以捕捉大小盘轮动行情的简单策略</title>
      <link href="2021/06/03/nian-hua-20-yi-ge-ke-yi-bu-zhuo-da-xiao-pan-lun-dong-xing-qing-de-jian-dan-ce-lue/"/>
      <url>2021/06/03/nian-hua-20-yi-ge-ke-yi-bu-zhuo-da-xiao-pan-lun-dong-xing-qing-de-jian-dan-ce-lue/</url>
      
        <content type="html"><![CDATA[<p>在A股市场的历史中，大小盘轮动是一个常见现象，大盘占优、小盘占优、大小盘均衡三种状态之间曾多次来回切换。</p><p>如果我们能<strong>利用大小盘股强势阶段在时间上的错位，不停地切换配置阶段占优的一方，必然能大幅提升投资收益。</strong></p><p>这篇文章就介绍了一个简单的方法，可以比较有效的捕捉到大小盘行情的轮动，那就是动量指标，我们以此作为切入点，来介绍一系列的大下盘风格轮动策略，这篇算是基础。</p><p>所谓动量指标，其实就是股价的N期涨跌幅，1个月动量就是最近1个月股价的涨跌幅，3个月动量就是最近3个月股价的涨跌幅。</p><p><strong>作为一个事后跟随指标，动量指标必然是滞后于股价变化的，但只要股价趋势运动延续的时间能较大程度地超过动量指标的周期参数N，动量指标就会有效。</strong></p><p>接下来，我们以量化回测的方法来看看<strong>基于动量指标的大小盘风格轮动策略</strong>在历史上业绩效果如何。</p><p><strong>【交易标的】</strong></p><p>我们以<a href="https://xueqiu.com/S/SH000300?from=status_stock_match">沪深300</a>指数作为大盘股的代理变量，以创业板作为小盘股的代理变量，交易标的指数如下：</p><p><img src="https://xqimg.imedao.com/175aadade62fd473feb9a0c9.png!800.jpg" alt="img"></p><p><strong>【测试时间】</strong></p><p>2013年1月1日～2020年9月30日</p><p><strong>【交易逻辑】</strong></p><p>买入并持有指数池中动量排名第一的指数，并在动量排名发生变化时进行调仓。</p><p><strong>【参数设置】</strong></p><p>本策略只含有1个参数，即动量指标的周期参数N，默认取N=20。</p><p>另外，ETF交易成本取万分之五，不考虑现金的利息收益。</p><p><strong>【测试结果】</strong></p><p>下表是风格轮动策略的业绩表现：</p><p><img src="https://xqimg.imedao.com/175aadade08fd463fcc6d72f.png!800.jpg" alt="img"></p><p><em>注:“B&amp;H策略”为买入并持有所有指数的等权组合</em></p><p><img src="https://xqimg.imedao.com/175aadade32100503fd11d34.png!800.jpg" alt="img"></p><p>图中，黑色粗线是风格轮动策略的历史净值走势，虚线是B&amp;H策略的历史净值走势。红线是<a href="https://xueqiu.com/S/SH000300?from=status_stock_match">沪深300</a>指数，红色线段表示策略此时持有沪深300，绿色是创业板。</p><p>上述风格轮动策略在测试期内的年化收益达到22.19%，显著高于B&amp;H策略13.78%的历史年化收益，这个级别的收益也是一个比较高的收益。</p><p>但是，策略的历史最大回撤高达56.35%，和B&amp;H策略的历史最大回撤相差无几，说明策略基本没有控制风险的能力，这个级别的回撤是无法令人接受的。</p><p>综合收益风险表现来看，策略的收益风险比仅为0.39，离我们的合格标准也还较远，因此，本策略不能直接应用于实盘。</p><p>本策略有一个<strong>明显的缺陷，就是在全面熊市时会一直持有股票资产，持续回撤，这就是本策略没有风险控制能力的根本原因。</strong></p><p>不过，这个缺点很容易改进，只要引入一个过滤条件使得策略可以避开全面熊市行情即可，比如，可以要求目标股票指数的动量必须大于0或者它的价格必选处于均线之上才可以买入，即使此时它的动量在所有股票指数中是最高的。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 理财 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>布林通道策略的投资效果如何？</title>
      <link href="2021/06/03/bu-lin-tong-dao-ce-lue-de-tou-zi-xiao-guo-ru-he/"/>
      <url>2021/06/03/bu-lin-tong-dao-ce-lue-de-tou-zi-xiao-guo-ru-he/</url>
      
        <content type="html"><![CDATA[<p><strong>布林通道</strong>(Bollinger Bands,简称BOLL)是一种股价通道指标，它由上、中、下三条轨道线组成，其中，中轨是一条股票价格的移动平均线，上轨等于移动平均线加上M倍的股价标准差，下轨等于移动平均线减去M倍的股价标准差，BOLL的计算方法可以表示为：</p><p><em>中轨Smd = SMA(CLOSE,N)</em></p><p><em>上轨Sup = Smd + M\</em>Sd*</p><p><em>下轨Sdn = Smd - M\</em>Sd*</p><p>其中，CLOSE代表股票收盘价，SMA(CLOSE,N)代表股票收盘价的N期移动平均线，Sd代表股价标准差。下图为布林通道示例：</p><p><img src="https://xqimg.imedao.com/1758bff44d66a503fdb978aa.png!800.jpg" alt="img"></p><p>布林通道认为，中轨是股价的运动的中枢，上轨是股价运动的压力线，下轨是股价运动的支撑线，上轨和下轨形成了一个带状区间，<strong>一般情况下，股价会在这个区间内来回波动。</strong></p><p>但是，<strong>一旦股价运动超过了这个区间，就说明市场很有可能发生了质的变化，</strong>向上突破上轨则说明市场可能进入了新的上涨趋势，这时候应该买入，向下跌破下轨则说明市场可能进入了新的下跌趋势，这时候应该卖出。</p><p>下面我们以量化回测方法，来分析布林通道策略(BOLL)的历史业绩表现：</p><p><strong>【交易标的】</strong></p><p>我们选取了12只对A股市场某个板块或行业具有很强代表性的股票指数，并分别单独利用BOLL策略对其进行择时交易，具体见下表：</p><p><strong>【测试时间】</strong></p><p>2013年1月1日～2020年9月30日</p><p><strong>【交易逻辑】</strong></p><p>当策略为空仓时，若收盘价高于布林通道的上轨，则买入并持有；当策略有持仓时，若收盘价低于布林通道的下轨，则卖出并空仓。</p><p><strong>【参数设置】</strong></p><p>本策略含有2个参数，即计算布林通道中轨的均线周期参数N和带宽参数M。默认N=20、M=2。</p><p><strong>【测试结果】</strong></p><p>布林通道策略(N=20,M=2)测试结果–业绩表现：</p><p><img src="https://xqimg.imedao.com/1758bff44dc6a513fcf0282c.png!800.jpg" alt="img"></p><p><em>注:“B&amp;H策略”为买入并持有策略，即在期初买入并一直持有到期末所能获得的投资业绩。</em></p><p>布林通道策略(N=20,M=2)的历史净值曲线：</p><p><img src="https://xqimg.imedao.com/1758bff44db6b703f921f1bc.png!800.jpg" alt="img"></p><p>布林通道策略等权组合的历史年化收益率为11.98%，和B&amp;H策略的年化收益率基本一致，BOLL策略在创造收益方面没有突出表现，它也没有创造显著超越B&amp;H策略收益的能力。</p><p>但BOLL策略在风险控制方面的表现较为突出，其等权组合的历史最大回撤仅22.95%，大幅低于B&amp;H策略的历史最大回撤</p><p>BOLL策略在回撤方面的良好表现得益于两方面，一是作为趋势跟随策略，BOLL策略可以避开部分熊市下跌行情，二是BOLL策略在震荡市中可以过滤掉不少虚假信号，因此它在震荡市的损耗也相对较小，这一点可以从上图看出，BOLL策略在2016年至2017年整体震荡市期间回撤较小。</p><p>BOLL策略的收益风险比为0.52，虽然离合格标准值1.0还有一定的距离，但在经典技术指标策略中已经算是比较高的了。</p><p>总的来说，BOLL策略单独使用的价值虽不高，但是如果在其基础上加以改进，则很有可能能得到一个不错的策略。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 理财 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>经典震荡指标用于指数基金择时的效果：以RSI为例</title>
      <link href="2021/06/02/jing-dian-zhen-dang-zhi-biao-yong-yu-zhi-shu-ji-jin-ze-shi-de-xiao-guo-yi-rsi-wei-li/"/>
      <url>2021/06/02/jing-dian-zhen-dang-zhi-biao-yong-yu-zhi-shu-ji-jin-ze-shi-de-xiao-guo-yi-rsi-wei-li/</url>
      
        <content type="html"><![CDATA[<p>在前面我们提到过，可以用来指导择时买卖交易的技术指标主要分两大类，趋势类指标和震荡类指标，趋势类指标诸如均线、动量等，震荡类指标主要有相对强弱指数(RSI)、慢速随机指标(SKDJ)等。</p><p>一般而言，趋势类指标在趋势行情中会比较有效，而在震荡盘整行情中会失效，而震荡类指标正好相反，在震荡盘整行情中会比较有效，而在趋势行情中会失效。<br>那么，<strong>在包括趋势和震荡的所有行情下，哪类指标会更有效呢？</strong>本文我们以经典震荡指标RSI为例来看看。</p><p>RSI指标，即相对强弱指数，它度量的是一段时间内股价运动总波幅中下跌部分的占比，RSI指标的取值范围为0～100%。</p><p>RSI指标可以用来捕捉股价的底部和顶部，具体操作时，我们以30%为临界值，即当RSI指小于30%时，认为股价已严重超跌，进入了底部区域，看好后续反弹。相应地，当RSI指标大于70%时，我们认为股价已严重超涨，进入了顶部区域，后续有回落风险。</p><p>下面我们以量化回测方法，来分析RSI指标策略的历史业绩表现：</p><p><strong>【交易标的】</strong></p><p>我们选取了10只对A股市场某个板块或行业具有很强代表性的股票指数，并分别单独利用RSI策略对其进行择时交易，具体见下表：</p><p><strong>【测试时间】</strong></p><p>2013年1月1日～2020年8月31日</p><p><strong>【交易逻辑】</strong></p><p>当策略为空仓时，若RSI指标上穿30%，则买入并持有；当策略有持仓时，若RSI指标下破70%，则卖出并空仓。</p><p><strong>【参数设置】</strong></p><p>本策略含有2个参数，即计算RSI指标的周期参数N和临界参数R。默认N=20、R=0.3。</p><p><strong>【测试结果】</strong></p><p>RSI策略(N=20,R=0.3)测试结果–业绩表现：</p><p><img src="https://xqimg.imedao.com/175877cf1d54fc83fec1d44a.png!800.jpg" alt="img"></p><p><em>注:“B&amp;H策略”为买入并持有策略，即在期初买入并一直持有到期末所能获得的投资业绩。</em></p><p>RSI策略(N=20,R=0.3)的历史净值曲线：</p><p><img src="https://xqimg.imedao.com/175877cf1e94f9c3fe626dec.png!800.jpg" alt="img"></p><p>RSI策略等权组合的历史年化收益率非常之低，仅2.13%，这似乎与我们平时对震荡指标的直观感受不一样，如果我们平时在炒股软件中研究过这些震荡指标，往往会觉得这些指标挺准，而实际上这是一种幻觉。</p><p><strong>之所以会觉得RSI指标择时挺准，是因为它的胜率比较高</strong>，可以达到62.7%，也即用RSI指标进行择时买卖，10次里面有6.3次是对的，所以会觉得它很有用。</p><p>但是，投资效果不仅仅是由胜率决定，还有盈亏比、平均持仓时间等，RSI指标的盈亏很低，仅1.09倍，具体可以看下表：</p><p><img src="https://xqimg.imedao.com/175877cf1ea4f5f3fe92b1ff.png!800.jpg" alt="img"></p><p>此外，RSI指标发出的买入信号数量很少，这也会造成RSI指标最终的投资收益很低。</p><p>当然我们可以通过提高RSI的临界参数R来触发更多的买入信号，但是这样势必会降低胜率，最终的投资效果不一定能得到提升。</p><p>震荡指标虽然从直观角度上看上去挺准挺有用，但从实际历史测试结果来看效果却很差，反而是胜率低的趋势类指标往往会有更好的效果。在投资实践中，也确实会发现，有效的择时策略往往是以趋势逻辑为主。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 理财 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>动量指标用于指数基金择时的效果如何？</title>
      <link href="2021/06/02/dong-liang-zhi-biao-yong-yu-zhi-shu-ji-jin-ze-shi-de-xiao-guo-ru-he/"/>
      <url>2021/06/02/dong-liang-zhi-biao-yong-yu-zhi-shu-ji-jin-ze-shi-de-xiao-guo-ru-he/</url>
      
        <content type="html"><![CDATA[<p><strong>动量指标</strong>，也叫变动率指标(Rate of Change, 简称<strong>ROC</strong>)，它等于最新的股票价格相较于N天前的股票价格的涨跌幅，即<strong>股价的N期涨跌幅</strong>。</p><p>下图是<a href="https://xueqiu.com/S/SH000300?from=status_stock_match">沪深300</a>指数的动量指标走势图示例：</p><p><img src="https://xqimg.imedao.com/175773e286eb063fd3e84370.png!800.jpg" alt="img"></p><p>动量指标即可以显示出股价运行的方向，当股票的动量指标值大于0时，说明股票价格的运行方向是上涨，这时候应该买入，而当股票的动量指标指小于0时，说明股票价格的运行方向是下跌，这时候应该卖出，这就是<strong>动量指标的核心使用逻辑</strong>。</p><p>但是，当动量指标在0附近来回拉锯时，会导致频繁的无效交易，因此，我们考虑一个缓冲空间，要求当动量指标大于R时才会买入，反之，要求当动量指标小于-R时才会卖出，这里的R我们称之为<strong>缓冲参数</strong>。</p><p>下面我们以量化回测方法，来详细分析动量指标策略(ROC)的历史业绩表现：</p><p><strong>【交易标的】</strong></p><p>我们选取了10只对A股市场某个板块或行业具有很强代表性的股票指数，并分别单独利用单均线策略对其进行择时交易，具体见下表：</p><p><img src="https://xqimg.imedao.com/175773e2872b403fc6d318d2.png!800.jpg" alt="img"></p><p><strong>【测试时间】</strong></p><p>2013年1月1日～2020年8月31日</p><p><strong>【交易逻辑】</strong></p><p>当策略为空仓时，若动量指标大于R，则买入并持有；当策略有持仓时，若动量指标小于-R，则卖出并空仓。</p><p><strong>【参数设置】</strong></p><p>本策略含有2个参数，即计算动量指标的<strong>周期参数N</strong>和<strong>缓冲参数R</strong>。默认N=20、R=0.01。</p><p><strong>【测试结果】</strong></p><p>ROC策略(N=20,R=0.01)测试结果–业绩表现：</p><p><img src="https://xqimg.imedao.com/175773e2875b073fecda69f3.png!800.jpg" alt="img"></p><p><em>注:“B&amp;H策略”为买入并持有策略，即在期初买入并一直持有到期末所能获得的投资业绩。</em></p><p>ROC策略(N=20,R=0.01)的历史净值曲线：</p><p><img src="https://xqimg.imedao.com/175773e2909b413fb69b26ff.png!800.jpg" alt="img"></p><p>ROC策略等权组合的历史年化收益率为14.48%，B&amp;H策略的历史年化收益是14.77%，两者非常接近。</p><p>具体来看，有差不多一半股票指数的ROC策略收益表现优于B&amp;H策略，诸如<a href="https://xueqiu.com/S/SZ399006?from=status_stock_match">创业板指</a>、<a href="https://xueqiu.com/S/SZ399975?from=status_stock_match">证券公司</a>以及<a href="https://xueqiu.com/S/SH000993?from=status_stock_match">全指信息</a>的，均是一些波动大、周期性强的指数，而像<a href="https://xueqiu.com/S/SH000932?from=status_stock_match">中证消费</a>、<a href="https://xueqiu.com/S/SH000913?from=status_stock_match">300医药</a>这种弱周期性的指数，ROC策略的收益表现普遍不如B&amp;H策略。</p><p><strong>作为一个趋势跟踪性质的策略，ROC策略应用于那些波动大、周期性强的指数，会更有可能取到好的投资效果。</strong></p><p>在强烈的下跌趋势中，ROC策略迟早会发出卖出或者空仓信号，躲过部分下跌行情，所以ROC策略具有一定的风险控制能力，它的历史最大回撤也应该低于B&amp;H策略。</p><p>ROC策略追求收益的能力和B&amp;H策略相差无几，但风险控制能力要明显强于B&amp;H策略，综合来看，ROC策略的投资业绩优于B&amp;H策略，但ROC策略的风险收益比只有0.42，达不到一个合格策略的标准。</p><p>不过，我们认为，ROC策略是有潜力的，值得我们对其进行更深入的研究，在经过改进之后，它很有希望能成为一个合格的策略。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 理财 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>指标之王MACD是否名副其实？</title>
      <link href="2021/06/02/zhi-biao-zhi-wang-macd-shi-fou-ming-fu-qi-shi/"/>
      <url>2021/06/02/zhi-biao-zhi-wang-macd-shi-fou-ming-fu-qi-shi/</url>
      
        <content type="html"><![CDATA[<p>MACD，全称叫“平滑异同移动平均线”，由格拉尔德·阿佩尔（Gerald Appel）在1979年提出，旨在利用股票价格的短期均线与长期均线之间的聚合与分离状况，来对买卖时机作出研判。</p><p>MACD指标由一根快线(DIF)和一根慢线(DEA)组成，在一般软件中，为显示方便，还会用红绿柱状图来显示快线与慢线之差。</p><p>下图是<a href="https://xueqiu.com/S/SH000300?from=status_stock_match">沪深300</a>指数日K线的MACD指标图：</p><p><img src="https://xqimg.imedao.com/175725a8cd8c7173fd1dccf6.jpg!800.jpg" alt="img"></p><p>MACD指标中的快线DIF是股票价格的12日指数移动平均线与26日指数移动平均线的差值，具体计算公式为：</p><p>DIF = EMA(CLOSE, 12) - EMA(CLOSE, 26);</p><p>慢线DEA是快线DIF的9日指数移动平均线，具体计算公式为：</p><p>DEA = EMA(DIF, 9)；</p><p><em>(<strong>*<em>注：\</em></strong></em>上面公式中，CLOSE代表股票价格，EMA代表指数移动平均线)*</p><p><strong>简单来说，MACD就是一长一短两根均线差值的均线，度量的是均线势能的变化。</strong></p><p>MACD指标最直接且最经典的用法是：<strong>当快线DIF上穿慢线DEA时(即金叉)买入，当快线DIF下穿慢线DEA时(即死叉)卖出。</strong></p><p>此方法具有完全的客观判断标准，可以很方便的用<a href="https://xueqiu.com/S/SH512720?from=status_stock_match">计算机</a>来实现，并对其进行历史测试。</p><p>MACD还有其他许多用法，比如底背离、顶背离等，但这些用法中的主观判断成份很重，没有统一客观的使用标准，不同的人使用的结果可能大不一样，也难以用<a href="https://xueqiu.com/S/SH512720?from=status_stock_match">计算机</a>来实现。</p><p>MACD在传统的主观技术分析领域使用非常广泛，且享誉极高，被誉为“<strong>指标之王</strong>”。</p><p>主观用法千人千面，因人而异，难以作统一评价，因此，我们这里只根据可客观化的用法来判断MACD的使用价值。</p><p>下面我们以量化回测方法，来详细分析单均线策略的历史业绩表现及交易特征：</p><p><strong>【交易标的】</strong></p><p>我们选取了10只对A股市场某个板块或行业具有很强代表性的股票指数，并分别单独利用单均线策略对其进行择时交易，具体见下表：</p><p><img src="https://xqimg.imedao.com/175725a8cb4c58e3feb8f453.png!800.jpg" alt="img"></p><p><strong>【测试时间】</strong></p><p>2013年1月1日～2020年8月31日</p><p><strong>【交易逻辑】</strong></p><p>当策略为空仓时，若DIF位于DEA之上，则买入并持有；当策略有持仓时，若DIF位于DEA之下，则卖出并空仓。</p><p><strong>【参数设置】</strong></p><p>本策略含有3个参数，即计算DIF时所需要用到的短均线周期M和长均线周期N，以及计算DEA时所需要用到的均线周期L。默认N=12、M=26、L=9。</p><p><strong>【测试结果】</strong></p><p>MACD策略(N=12,M=26,L=9)测试结果–业绩表现：</p><p><img src="https://xqimg.imedao.com/175725a8cafc4d63fa479675.png!800.jpg" alt="img"></p><p>注:“B&amp;H策略”为买入并持有策略，即在期初买入并一直持有到期末所能获得的投资业绩。</p><p>MACD策略(N=12,M=26,L=9)的资金曲线：</p><p><img src="https://xqimg.imedao.com/175725a8cb7c6173fe0d7b15.png!800.jpg" alt="img"></p><p>MACD策略等权组合的历史年化收益率较低，仅11.61%，也低于B&amp;H策略的年化收益率的，因此，MACD策略没有创造超额收益的能力。MACD策略的历史最大回撤明显低于B&amp;H策略，这说明，MACD策略有较好的风险控制能力。</p><p><strong>MACD指标的核心功能在于度量均线势能的变化，或者说是股价的二阶差变化</strong>，当股价上涨开始乏力时，MACD指标往往能较早的发出卖出信号，使得策略能在股价开始拐头下跌时及时离场，这是MACD指标具有较好风险控制能力的原因。</p><p><strong>但是，当遇到大型的趋势上涨行情时，MACD指标也会错误地过早离场，虽然根据策略逻辑，之后还会继续发出买入信号，但难免错失一段利润，</strong>所以在趋势上涨行情中，MACD策略的投资收益会不如股票指数的自身涨幅。</p><p>MACD策略含有3个参数，如果要做参数优化，成本将比较高。我们也尝试过去测试不同参数的MACD策略表现，发现历史年化收益基本在6～13%之间，仍然不如B&amp;H策略。</p><p>此外，MACD策略的默认参数组(12,26,9)对应的历史年化收益率为11.61%，在所有参数组中的收益表现已经处于中等偏上的位置了，依靠参数优化所能带来的策略改进空间已经很小，而且一般来说，除非有充分的理由，否则我们不应该放弃指标的经典参数组，而去选用其他参数组。</p><p>因此，起码从客观使用方法来看，称MACD为“指标之王”名过其实</p>]]></content>
      
      
      
        <tags>
            
            <tag> 理财 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>双均线交易策略是否比单均线策略更有效？</title>
      <link href="2021/06/02/shuang-jun-xian-jiao-yi-ce-lue-shi-fou-bi-dan-jun-xian-ce-lue-geng-you-xiao/"/>
      <url>2021/06/02/shuang-jun-xian-jiao-yi-ce-lue-shi-fou-bi-dan-jun-xian-ce-lue-geng-you-xiao/</url>
      
        <content type="html"><![CDATA[<p>和我们事先预料的一致，仅用单均线指标来做交易的效果并不好，事实上，主流的常见技术指标直接用于交易的效果都不太好。</p><p>但单一指标毕竟是多指标策略的基础，所以搞清楚它们的性能、特征，也是有必要的。</p><p>单均线策略虽然能在牛市中抓住大部分行情，同时在熊市中躲过大跌，但它在震荡市中拉锯的太厉害，对价格的无序噪音波动基本没什么过滤能力，经常是买入之后价格就回落，卖出之后价格又反弹，被来回打脸的频率太高。</p><p>相较而言，<strong>双均线策略在震荡市中受价格的噪音波动影响会小一些，被来回打脸的次数会少许多，但代价是，在真正的上涨趋势启动时，入场没有单均线策略快，而在上涨趋势结束时，出场又比单均线策略慢。</strong></p><p>下面我们以量化回测方法，来详细分析单均线策略的历史业绩表现及交易特征：</p><p><strong>【交易标的】</strong></p><p>我们选取了10只对A股市场某个板块或行业具有很强代表性的股票指数，并分别单独利用单均线策略对其进行择时交易，具体见下表：</p><p><strong>【测试时间】</strong></p><p>2013年1月1日～2020年8月31日</p><p><strong>【交易逻辑】</strong></p><p>(1)使用股票指数的收盘价计算出两根简单均线：N日均线（短均线）和M日均线（长均线），并且N&lt;M；</p><p>(2)当短均线上穿长均线时买入，当短均线下穿长均线时卖出。</p><p><strong>【参数设置】</strong></p><p>本策略含有2个参数，即短均线的周期长度N和长均线的周期长度M。</p><p>短均线参数N：5~100日，间隔为5，共计20个参数；</p><p>长均线参数M：10~250日，间隔为10，共计25个参数；</p><p>N必须小于M，满足条件的参数组合为400组。</p><p><strong>【测试结果】</strong></p><p>对于双均线策略而且，两个参数N和M默认取值并不是很好定，因此我们直接来看N和M的各参数组的的收益表现，见下图：</p><p><img src="https://xqimg.imedao.com/1756d484703a5343fbfc911e.png!800.jpg" alt="img"></p><p>总的来说，策略年化收益率基本集中在8~12%之间，和单均线策略基本差不多，特定参数下，要比单均线策略好一些，但与之而来的是，双均线策略对参数的更为敏感一些。</p><p>接下来，我们选取以N和M取(20,120)为列来看看双均线策略的具体表现，这两个均线周期恰好是月线和半年线，具有一定的代表性。</p><p><img src="https://xqimg.imedao.com/1756d484784a6bb3fef50dab.png!800.jpg" alt="img"></p><p>双均线策略(N=20,M=120)的年化收益虽然比单均线策略要高一些，但是还明显低于指数等权组合自身的年化涨幅，也就是说，和单均线策略一样，双均线策略也没有创造超额收益的能力。</p><p><strong>这再一次验证了我们在前面所说的一个观点，绝大多数常见的技术指标的单独运用表现都不好，都不能直接应用到实盘中去。</strong></p>]]></content>
      
      
      
        <tags>
            
            <tag> 理财 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>利用移动平均线进行择时交易的效果如何？</title>
      <link href="2021/06/02/li-yong-yi-dong-ping-jun-xian-jin-xing-ze-shi-jiao-yi-de-xiao-guo-ru-he/"/>
      <url>2021/06/02/li-yong-yi-dong-ping-jun-xian-jin-xing-ze-shi-jiao-yi-de-xiao-guo-ru-he/</url>
      
        <content type="html"><![CDATA[<p>移动平均线（即均线，Moving Average,简称MA）是将一段时期内(比如20日)的证券价格的平均值连成曲线。均线是最常见、最简单，也是使用最为广泛的技术指标。</p><p>在通达信软件里，只要在某只股票或股票指数的K线图界面输入字母“<strong>MA</strong>”，就可以得到它的均线走势图，比如下图是<a href="https://xueqiu.com/S/SH000300?from=status_stock_match">沪深300</a>指数的均线图：</p><p><img src="https://xqimg.imedao.com/17568a5ecd78b803fe11b09f.jpg!800.jpg" alt="img"></p><p><strong>均线可以平滑掉价格在短期无序的噪音波动，反映出价格的长期趋势方向，并通过倾斜度暗示趋势的强度。</strong></p><p>比如，在上图中，20日均线反映的<a href="https://xueqiu.com/S/SH000300?from=status_stock_match">沪深300</a>指数月级别的价格趋势，它大致可以过滤掉价格在周级别的无序噪音波动，而120日均线反映的沪深300指数半年级别的价格趋势，它大致可以过滤掉价格在月级别的无序噪音波动。</p><p>利用单根均线进行择时买卖交易的规则比较简单：股票价格上穿均线时买入，股票价格下穿均线时卖出。</p><p>下面我们以量化回测方法，来详细分析单均线策略的历史业绩表现及交易特征：</p><p><strong>【交易标的】</strong></p><p>我们选取了10只对A股市场某个板块或行业具有很强代表性的股票指数，并分别单独利用单均线策略对其进行择时交易，具体见下表：</p><p><img src="https://xqimg.imedao.com/17568a5ec7d8b3c3fe429aad.png!800.jpg" alt="img"></p><p><strong>【测试时间】</strong></p><p>2013年1月1日～2020年8月31日</p><p><strong>【交易逻辑】</strong></p><p>股票指数的收盘价上穿N日均线时买入，价格下穿N日均线时卖出</p><p><strong>【参数设置】</strong></p><p>本策略含有1个参数，即均线的周期长度N，默认取N=20日，常用的均线周期有10日、20日、30日、60日、120日。</p><p><strong>【测试结果】</strong></p><p>我们分别对各股票指数应用本策略进行测试，均线周期长度取N=5,10,…,250，其中步长为5，共计50个参数，各参数对应股票指数等权组合策略收益率图如下：</p><p><img src="https://xqimg.imedao.com/17568a5ecce8b7f3fcb1fe50.png!800.jpg" alt="img"></p><p>从上图可知，当均线参数取值在10以上时，其对应的策略年化收益率基本在8%至10%之间，从绝对角度看，这个级别的收益率是不能让我们满意的。</p><p>接下来，我们选取N=20为代表性参数，来看看单均线策略的详细表现：</p><p><img src="https://xqimg.imedao.com/17568a5ecf88a823febad7af.png!800.jpg" alt="img"></p><p>从测试结果看：</p><p><strong>(1)单均线交易策略的收益表现并不好。</strong>年化收益率还不到10%，而指数等权组合的自身年化涨幅为14.77%，策略收益表现还跑不过指数自身涨幅。</p><p><strong>(2)单均线策略的最大回撤很高</strong>，达到了38.44%，虽然比指数组合自身的最大回撤要小一些，但这仍然是一个很高的值，说明<strong>单均线策略控制投资风险的能力很弱。</strong></p><p>综合收益风险来看，单均线策略不是一个好策略，并不适合直接用来进行择时交易。</p><p><strong>实际上，绝大多数常见的技术指标的单独运用表现都不好，都不能直接应用到实盘中去。</strong></p><p>我们这里做这个分析的主要目的，一是通过具体数据让大家明白这一点，二是了解均线交易策略的特征表现。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 理财 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>如今的使用效果如何？</title>
      <link href="2021/06/01/ru-jin-de-shi-yong-xiao-guo-ru-he/"/>
      <url>2021/06/01/ru-jin-de-shi-yong-xiao-guo-ru-he/</url>
      
        <content type="html"><![CDATA[<p>在丹尼斯和他的海龟们所使用的交易策略中，最主要的就是<strong>唐奇安通道策略</strong>(Donchian Chanels)。一般我们所说的海龟交易策略，其实就是指唐奇安通道策略。</p><p>唐奇安通道是一种通道股价通道指标，它的上轨是最近N日的最高价，它的下轨是最近M日的最低价，默认N取40，M取N的一半，即20，唐奇安通道的计算方法可以表示为：</p><p><em>上轨HHigh = HHV(High,40)，最近40日最高价的最大值；</em></p><p><em>下轨LLow = LLV(Low,20)，最近20日最低价的最小值；</em></p><p><img src="C:\Users\He\Desktop\17596459d46a6243fc0f1e77.png!800.jpg" alt="img"></p><p>唐奇安通道策略的基本思路很简单，就是价格突破一定时间内的最高点就买入，反之，跌破一定时间内的最低点就卖出。</p><p>下面我们以量化回测方法，来分析海龟交易策略的历史业绩表现：</p><p><strong>【交易标的】</strong></p><p>我们选取了12只对A股市场某个板块或行业具有很强代表性的股票指数，并分别单独利用BOLL策略对其进行择时交易，具体见下表：</p><p><strong>【测试时间】</strong></p><p>2013年1月1日～2020年9月30日</p><p><strong>【交易逻辑】</strong></p><p>当策略为空仓时，若收盘价高于过去N日最高价的最大值，则买入并持有；当策略有持仓时，若收盘价低于过去M日最低价的最小值，则卖出并空仓。</p><p><strong>【参数设置】</strong></p><p>本策略只含有1个参数，即计算上轨的周期参数N，默认N=40，计算下轨的周期参数M=N/2=20。</p><p><strong>【测试结果】</strong></p><p>海龟交易策略(N=40)测试结果–业绩表现：</p><p><img src="https://xqimg.imedao.com/17596459d4ba89c3fe55c483.png!800.jpg" alt="img"></p><p><em>注:“B&amp;H策略”为买入并持有策略，即在期初买入并一直持有到期末所能获得的投资业绩。</em></p><p>海龟交易策略(N=40)的历史净值曲线：</p><p><img src="https://xqimg.imedao.com/17596459d4fa8a43fef54ca2.png!800.jpg" alt="img"></p><p>从策略年化收益看，海龟交易策略完全达不到我们的预期，其在测试期内的年化收益仅为7.72%，显著低于B&amp;H策略的收益表现。</p><p>海龟交易策略的历史最大回撤为32.24%，虽然显著低于B&amp;H策略的历史最大回撤，但从绝对角度看，也是一个较高级别的回撤值。</p><p>综合来看，海龟交易策略的收益风险比也仅为0.24，即无创造超额收益的能力，又无优秀的风险控制能力，显然，海龟交易策略目前已经没有单独使用的价值了，最起码对默认参数而言是如此。至于其他参数，我们也测试过，情况会稍微好一些，但也没有本质区别。</p><p>最后补充说明一点，丹尼斯和他的海龟们交易的是商品期货，多空都可以做，且他们在使用这个策略时还涉及到基于ATR(平均真实波动)的资金管理，这里跟我们有所不同。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 理财 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>海龟交易策略：一个传奇的交易故事</title>
      <link href="2021/06/01/hai-gui-jiao-yi-ce-lue-yi-ge-chuan-qi-de-jiao-yi-gu-shi/"/>
      <url>2021/06/01/hai-gui-jiao-yi-ce-lue-yi-ge-chuan-qi-de-jiao-yi-gu-shi/</url>
      
        <content type="html"><![CDATA[<p>海龟交易策略的诞生，是交易界的一个传奇故事，它源于1983年美国著名的交易大师理查德·丹尼斯和他的朋友比尔·埃克哈特在新加坡一个海龟农场时定下的一个<strong>赌局</strong>：</p><p><strong>丹尼斯认为伟大的交易员是可以后天培养的，就像新加坡人养海龟一样，而比尔认为伟大的交易员是天生的，不可培养。</strong></p><p>为此，丹尼斯在报纸上刊登了大幅广告，招募了13个人来参加他的交易培训计划，丹尼斯教授给他们期货的基本概念，以及他自己的交易方法和法则，这些学员就被称作“<strong>海龟</strong>”。</p><p>在经过两个星期的培训之后，丹尼斯给了海龟们每人一个100万美元的账户进行期货交易。在外人看来，在两个星期内培养出一批交易员，或许有些天方夜谭。</p><p>但丹尼斯认为，只要学员能贯彻实施自己的交易方法和法则，两个星期绰绰有余。事实上，丹尼斯在第二年招募新一批海龟时，只用一个星期就完成了培训。</p><p>之后的4年里，海龟们取得了年化80%的收益，毫无疑问，丹尼斯赢得了赌局，他证明了只要有一套有效的交易方法和法则，很少或者根本没有交易经验的人都可以成为优秀的交易员。</p><p><strong>《海龟交易法则》</strong>一书的作者柯蒂斯·费思是海龟中最优秀也是交易成绩最好的一个，并且在整个海龟计划期间，柯蒂斯的账户始终是金额最大的那个。</p><p>丹尼斯教授给所有海龟的交易方法和法则都是一样的，那么为什么柯蒂斯的交易成绩最好？</p><p>答案是<strong>柯蒂斯最能贯彻执行丹尼斯所教授的交易方法和法则，柯蒂斯拥有最完善的海龟交易思维。</strong></p><p><strong>海龟交易思维主要就是三点：</strong></p><p><strong>(1)相信正期望的威力</strong></p><p>我们先用一个例子来说明什么是正期望。</p><p>假如我们掌握了一种抛硬币的策略，有60%的概率可以抛出正面，每次抛出正面可以赚1元，抛出反面亏1元，那么我们每次抛硬币的期望盈利是0.6元*(1元*60%)<em>，每次抛硬币的期望亏损是负0.4元</em>(-1元*40%)<em>，而每次抛硬币的期望盈利值就等于0.2元</em>（0.6元-0.4元=0.2元）*。</p><p>显然，这个抛硬币的策略是有正期望的，用通俗的话来说，就是有胜算，每次抛硬币的正期望是盈利0.2元。如果我们将这个抛硬币的游戏一直玩下去，一次两次可能亏损，但长期必然是盈利的。</p><p>对海龟们来说，丹尼斯所传授教授的就是具有正期望的方法，只要相信这个交易方法长期必然盈利就可以了。</p><p><strong>(2)避免结果偏好</strong></p><p>所谓<strong>结果偏好，是指人们倾向于根据一个决策的结果来判断它的好坏，而不是决策本身的质量。</strong></p><p>假如有一个抛硬币的游戏，有50%的概率抛到正面，50%概率抛到负面，抛到正面赚1元，抛到负面亏1.2元。显然，这个游戏是不能参加的，因为它的期望值为负。如果我们只抛一次两次硬币，完全有可能盈利，但我们不能因为结果是盈利就说参加这个游戏是对的。</p><p>对海龟们来说，<strong>每一次根据策略进行的交易，即使亏损，也是正确的；而每一次没有按照策略进行的交易，即使盈利，也是错误的。</strong></p><p><strong>(3)以长远的眼光看待交易</strong></p><p>对海龟们来说，亏损交易只是做生意的成本，并不代表一次错误交易或者错误决策。只要坚持使用具有正期望的交易策略，短期有可能亏损，但长期必然盈利。</p><p>柯蒂斯总结海龟们获得成功的首要原因就是，对丹尼斯所传授的交易方法和法则有信心，能坚定不移、始终如一地照着策略的信号来交易。</p><p>这说明：<strong>一个行之有效的策略，持之以恒的执行下去，长期盈利可以说是必然的。</strong></p><p>我们恰好见过很多反面案例，在这些最终没有取得好业绩的策略投资者中，最主要的原因正是因为没有贯彻执行策略所发出的信号</p>]]></content>
      
      
      
        <tags>
            
            <tag> 理财 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python</title>
      <link href="2021/04/13/python/"/>
      <url>2021/04/13/python/</url>
      
        <content type="html"><![CDATA[<h1 id="Python"><a href="#Python" class="headerlink" title="Python"></a>Python</h1><blockquote><p>记录一下使用Python是遇到的一些问题</p></blockquote><h2 id="使用轮子安装"><a href="#使用轮子安装" class="headerlink" title="使用轮子安装"></a>使用轮子安装</h2><ol><li>下载适合自己版本的轮子</li></ol><p>轮子地址：<a href="https://www.lfd.uci.edu/~gohlke/pythonlibs/">https://www.lfd.uci.edu/~gohlke/pythonlibs/</a></p><ol start="2"><li><p>安装</p><pre><code>pip install TA_Lib-0.4.19-cp38-cp38-win32.whl</code></pre></li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>大小盘轮动</title>
      <link href="2021/04/12/da-xiao-pan-lun-dong/"/>
      <url>2021/04/12/da-xiao-pan-lun-dong/</url>
      
        <content type="html"><![CDATA[<h1 id="无脑大小盘轮动"><a href="#无脑大小盘轮动" class="headerlink" title="无脑大小盘轮动"></a>无脑大小盘轮动</h1><blockquote><p> 我大A风格明显，一段时间大盘好于中小盘，一段时间中小盘好于大盘。所以就有了以下策略</p><p>量化策略：<a href="https://mp.weixin.qq.com/s/hPjVbBKomfMhowc32jUwhA">https://mp.weixin.qq.com/s/hPjVbBKomfMhowc32jUwhA</a></p></blockquote><h2 id="回测"><a href="#回测" class="headerlink" title="回测"></a>回测</h2><ol><li><p>交易对象：沪深300（或上证50）、创业板指数的ETF（或中证500），前者代表大市值，后者代表小市值。（选择两个长期向上的、相关性低的指数）</p></li><li><p>筛选条件：用最近N日的涨跌幅，作为筛选条件（默认N=20，即大约为最近一个月）。</p></li><li><p>风格轮动：每日根据条件，选择涨幅大的指数持有。</p></li></ol><h3 id="回测代码"><a href="#回测代码" class="headerlink" title="回测代码"></a>回测代码</h3><pre class=" language-Python"><code class="language-Python">import pandas as pdimport numpy as npfrom function import *import matplotlib.pyplot as pltimport osos.chdir(os.path.abspath(os.path.dirname(__file__)))pd.set_option('expand_frame_repr', False)  # 当列太多时不换行# pd.set_option('display.max_rows', 5000)  # 最多显示数据的行数# 读取数据# df_coin1 = pd.read_csv('BTCUSD-1d.csv', encoding='gbk', parse_dates=['candle_end_time'])# df_coin2 = pd.read_csv('ETHUSD-1d.csv', encoding='gbk', parse_dates=['candle_end_time'])df_coin1 = pd.read_csv('SZ#159919.txt', encoding='gbk', header=1, names=['candle_end_time', 'open', 'high', 'low', 'close', 'volume', 'amount'])df_coin2 = pd.read_csv('SH#510500.txt', encoding='gbk', header=1, names=['candle_end_time', 'open', 'high', 'low', 'close', 'volume', 'amount'])df_coin1 = df_coin1.dropna()df_coin2 = df_coin2.dropna()# df_coin1['candle_end_time'] = df_coin1['candle_end_time'] + ' 08:00:00'# df_coin2['candle_end_time'] = df_coin2['candle_end_time'] + ' 08:00:00'df_coin1['candle_end_time'] = pd.to_datetime(df_coin1['candle_end_time'], format='%Y-%m-%d')df_coin2['candle_end_time'] = pd.to_datetime(df_coin2['candle_end_time'], format='%Y-%m-%d')# print(df_coin1)# print(df_coin2)# 设置参数# trade_rate = 2.5 / 1000  # 千分之2.5的交易费用远高于市场平均水平trade_rate = 0.6/10000  # 千分之2.5的交易费用远高于市场平均水平# trade_rate = 0  # 千分之2.5的交易费用远高于市场平均水平momentum_days = 20  # 计算多少天的涨跌幅# 计算两种币每天的涨跌幅pctdf_coin1['coin1_pct'] = df_coin1['close'].pct_change(1)df_coin2['coin2_pct'] = df_coin2['close'].pct_change(1)# 重命名行df_coin1.rename(columns={'open': 'coin1_open', 'close': 'coin1_close'}, inplace=True)df_coin2.rename(columns={'open': 'coin2_open', 'close': 'coin2_close'}, inplace=True)# 合并数据df = pd.merge(left=df_coin1[['candle_end_time', 'coin1_open', 'coin1_close', 'coin1_pct']], left_on=['candle_end_time'],              right=df_coin2[['candle_end_time', 'coin2_open', 'coin2_close', 'coin2_pct']],              right_on=['candle_end_time'], how='left')# 计算N日的涨跌幅momentumdf['coin1_mom'] = df['coin1_close'].pct_change(periods=momentum_days)df['coin2_mom'] = df['coin2_close'].pct_change(periods=momentum_days)# 轮动条件df.loc[df['coin1_mom'] > df['coin2_mom'], 'style'] = 'coin1'df.loc[df['coin1_mom'] < df['coin2_mom'], 'style'] = 'coin2'df.loc[(df['coin1_mom'] < 0) & (df['coin2_mom'] < 0), 'style'] = 'empty'# 相等时维持原来的仓位。df['style'].fillna(method='ffill', inplace=True)# 收盘才能确定风格，实际的持仓pos要晚一天。df['pos'] = df['style'].shift(1)# 删除持仓为nan的天数df.dropna(subset=['pos'], inplace=True)# 数字货币从17年开始回测# df = df[df['candle_end_time'] >= pd.to_datetime('20170101')]# 计算策略的整体涨跌幅strategy_pctdf.loc[df['pos'] == 'coin1', 'strategy_pct'] = df['coin1_pct']df.loc[df['pos'] == 'coin2', 'strategy_pct'] = df['coin2_pct']df.loc[df['pos'] == 'empty', 'strategy_pct'] = 0# 调仓时间df.loc[df['pos'] != df['pos'].shift(1), 'trade_time'] = df['candle_end_time']# 将调仓日的涨跌幅修正为开盘价买入涨跌幅df.loc[(df['trade_time'].notnull()) & (df['pos'] == 'coin1'), 'strategy_pct_adjust'] = df['coin1_close'] / (df['coin1_open'] * (1 + trade_rate)) - 1df.loc[(df['trade_time'].notnull()) & (df['pos'] == 'coin2'), 'strategy_pct_adjust'] = df['coin2_close'] / (df['coin2_open'] * (1 + trade_rate)) - 1df.loc[df['trade_time'].isnull(), 'strategy_pct_adjust'] = df['strategy_pct']# print(df)# 扣除卖出手续费（这里存在一个BUG，因为我大A不是T+0的交易方式，所以当天买入，当天是不能卖出的）暂时略过这个BUG，后期可修改为一周操作一次。或者修改为开盘卖出df.loc[(df['trade_time'].shift(-1).notnull()) & (df['pos'] != 'empty'), 'strategy_pct_adjust'] = (1 + df['strategy_pct_adjust']) * (1 - trade_rate) - 1# df.loc[(df['trade_time'].shift(-1).notnull()) & (df['pos'] != 'empty'), 'strategy_pct_adjust'] = (1 + df['strategy_pct']) * (1 - trade_rate) - 1# 将只持有一天的数据，推迟到第二天开盘卖出df.loc[(df['pos'] == 'coin2') & (df['pos'].shift(-1) != 'coin2') & (df['pos'].shift(1) != 'coin2'), 'strategy_pct_adjust'] = df['coin2_open'].shift(-1) / (df['coin2_open'] * (1 + trade_rate)) - 1df.loc[(df['pos'] == 'coin1') & (df['pos'].shift(-1) != 'coin1') & (df['pos'].shift(1) != 'coin1'), 'strategy_pct_adjust'] = df['coin1_open'].shift(-1) / (df['coin1_open'] * (1 + trade_rate)) - 1# print(df)# 空仓的日子，涨跌幅用0填充df['strategy_pct_adjust'].fillna(value=0.0, inplace=True)del df['strategy_pct'], df['style']df.reset_index(drop=True, inplace=True)# 计算净值df['coin1_net'] = df['coin1_close'] / df['coin1_close'][0]df['coin2_net'] = df['coin2_close'] / df['coin2_close'][0]df['strategy_net'] = (1 + df['strategy_pct_adjust']).cumprod()# 评估策略的好坏res = evaluate_investment(df, 'strategy_net', time='candle_end_time')print(res)# 绘制图片plt.plot(df['candle_end_time'], df['strategy_net'], label='strategy')plt.plot(df['candle_end_time'], df['coin1_net'], label='coin1_net')plt.plot(df['candle_end_time'], df['coin2_net'], label='coin2_net')plt.show()# 保存文件print(df.tail(10))df.to_excel('大小盘轮动12.xlsx', encoding='gbk', index=False)</code></pre><h3 id="回测结果"><a href="#回测结果" class="headerlink" title="回测结果"></a>回测结果</h3><p><img src="https://img-blog.csdnimg.cn/20210412231938952.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlMTcyMDczNjc1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p>以上回测结果是明显好于两个标的物的。</p><p>我们再看看回测控制的如何</p><pre><code>累积净值                     3.99年化收益                   19.09%最大回撤                  -30.04%最大回撤开始时间  2018-01-24 00:00:00最大回撤结束时间  2019-01-22 00:00:00年化收益/回撤比                 0.64</code></pre><p>也是非常好的，30%的最大回撤是我可接受的</p>]]></content>
      
      
      
        <tags>
            
            <tag> 理财 </tag>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ETF策略</title>
      <link href="2021/04/10/etf-ce-lue/"/>
      <url>2021/04/10/etf-ce-lue/</url>
      
        <content type="html"><![CDATA[<h1 id="ETF策略"><a href="#ETF策略" class="headerlink" title="ETF策略"></a>ETF策略</h1><blockquote><p>分享一个比较有效的投资策略</p></blockquote><h2 id="RSI"><a href="#RSI" class="headerlink" title="RSI"></a>RSI</h2><blockquote><p> RSI ，即相对强弱指标，是由韦尔斯.怀尔德(Welles Wilder)提出的，是衡量证券自身内在 相对强度的指标。相对强弱指数 RSI 是根据一定时期内上涨和下跌幅度之和的比率制作出的 一种技术曲线，能够反映出市场在一定时期内的景气程度。因为投资的一般原理认为，投资 者的买卖行为是各种因素综合结果的反映，行情的变化最终取决于供求关系，而 RSI 指标正 是根据供求平衡的原理，通过测量某一个期间内股价上涨总幅度占股价变化总幅度平均值的 百分比，来评估多空力量的强弱程度，进而提示具体操作的。 </p></blockquote><blockquote><p> RSI 公式不仅能够提供这种平滑特征，而且可以产生一个能够在 0-100 之间固定区域变 动的指标。怀尔德推荐的默认时间跨度是 14 天，他论证了应用月周期 28 日的一半是有效 的。 </p></blockquote><h3 id="计算公式"><a href="#计算公式" class="headerlink" title="计算公式"></a>计算公式</h3><blockquote><p> 计算公式： N 日 RSI =N 日内收盘涨幅的平均值/(N 日内收盘涨幅均值+N 日内收盘跌幅均值) ×100  </p></blockquote><h3 id="实际应用"><a href="#实际应用" class="headerlink" title="实际应用"></a>实际应用</h3><blockquote><p> 由上面算式可知 RSI 指标的技术含义，即以向上的力量与向下的力量进行比较，若向上 的力量较大，则计算出来的指标上升；若向下的力量较大，则指标下降，由此测算出市场走 势的强弱。 </p></blockquote><blockquote><p>市场上一般的规则：（快速 RSI 指 14 日的 RSI，慢速 RSI 指 6 日的 RSI） </p><ol><li>RSI 金叉：快速 RSI 从下往上突破慢速 RSI 时,认为是买进机会。 </li><li>RSI 死叉：快速 RSI 从上往下跌破慢速 RSI 时,认为是卖出机会 </li><li>慢速 RSI&lt;20 为超卖状态,为买进机会。 </li><li>慢速 RSI&gt;80 为超买状态,为卖出机会。</li></ol></blockquote><p>以上为RSI的常规用法</p><h2 id="非常规用法"><a href="#非常规用法" class="headerlink" title="非常规用法"></a>非常规用法</h2><blockquote><p>这是从B站大V那得到的一种应用，用RIS来判断大盘或者行业处于牛市还是熊市。</p></blockquote><blockquote><p>RSI的非常规用法：</p><ol><li>将RSI设置为14日，没错，只是用一个指标</li><li>牛市在40到70+区域波动</li><li>熊市在60到30-区域波动</li></ol><p>用来判断大盘或行业的牛熊变迁，和可能的转折</p></blockquote><h2 id="专属用法"><a href="#专属用法" class="headerlink" title="专属用法"></a>专属用法</h2><blockquote><p>忽略牛熊市，低于一定指标买入，高于一定指数卖出</p></blockquote><h3 id="回测数据"><a href="#回测数据" class="headerlink" title="回测数据"></a>回测数据</h3><p>回测2016年末至2020年末获得的收益表现如下：</p><p><img src="https://img-blog.csdnimg.cn/20210411001207618.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlMTcyMDczNjc1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p>结果表现跌倒40买入，高于70卖出收益最好。获得年化复合收益率为33.8957697%的良好表现</p><p>最大跌幅为-29.60%</p><pre><code>2017/4/21    1.0132    军工ETF    37.11809157    买入    2019/2/19    0.7133    军工ETF    71.51191712    卖出    -29.60%</code></pre><p>此次亏损时间长达22个月，慢刀子割肉呀</p><p>追加一个策略，以应对长期下跌的情况</p><blockquote><p>以40以下买入，70以下卖出为例</p><ol><li>跌破30，追加第二笔资金；跌破20，再追加第三笔资金</li><li>涨超60逐步卖出</li></ol></blockquote><p>PS：以上为历史回测数据，不作为投资参考。</p><h3 id="追加回测数据"><a href="#追加回测数据" class="headerlink" title="追加回测数据"></a>追加回测数据</h3><p><img src="https://img-blog.csdnimg.cn/20210411101600336.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlMTcyMDczNjc1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>]]></content>
      
      
      
        <tags>
            
            <tag> 理财 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>股债轮动</title>
      <link href="2021/04/09/gu-zhai-lun-dong/"/>
      <url>2021/04/09/gu-zhai-lun-dong/</url>
      
        <content type="html"><![CDATA[<h2 id="股债轮动策略"><a href="#股债轮动策略" class="headerlink" title="股债轮动策略"></a>股债轮动策略</h2><h3 id="利率与股市关系"><a href="#利率与股市关系" class="headerlink" title="利率与股市关系"></a>利率与股市关系</h3><blockquote><p>利率与股票的影响关系从资金面来分析，如果利率下调，市场资金将充沛，股市机会成本减少，资金流入，股市上涨，反之利率上调股市将会下跌。</p><p>从企业的角度看，利率的变动会对公司的经营环境产生影响，改变公司的业绩，引起公司资本价值以及投资者预期的变化，而使股价变动。利率下调对股票市场的影响很直接，投资成本降低，预期投资收益提高，对投资有刺激作用。</p><p>传统经济学理论认为利率的变动与股票价格变动成负相关关系，既利率上升、股价下跌，利率下调、股价上涨。</p></blockquote><h3 id="国债与股市轮动"><a href="#国债与股市轮动" class="headerlink" title="国债与股市轮动"></a>国债与股市轮动</h3><blockquote><p>国债作为固收类产品，国债收益率较高的时候，会吸引资金从高风险领域流入低风险的国债，其他资产价格就会下跌； 国债利率低，就会导致资金流入高风险领域，直接买入股票或购买股票型基金等。</p></blockquote><h3 id="根据股债盈利收益率判断股市的大概位置"><a href="#根据股债盈利收益率判断股市的大概位置" class="headerlink" title="根据股债盈利收益率判断股市的大概位置"></a>根据股债盈利收益率判断股市的大概位置</h3><p><img src="https://img-blog.csdnimg.cn/20210413000544213.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlMTcyMDczNjc1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p>说明：</p><ul><li>股债比 = 股盈利收益率 / 十年期国债收益率 = (1/市盈率) / 十年期国债收益率 = (1/十年期国债收益率) / 市盈率</li></ul><p>了解公式后，我们可以自己制作该图，并实时监控，及时预警。</p><h3 id="股债比策略"><a href="#股债比策略" class="headerlink" title="股债比策略"></a>股债比策略</h3><p>既然已经知道股市的大概位置，我们就得好好利用。制定一个简单的策略：</p><ol><li>股债比 &gt; 2.8时，全仓买入沪深300</li><li>股债比 &lt; 2时，清仓</li><li>其他时候，持仓观望</li></ol><p>从2008年末-2021年末情况如下</p><ul><li>第一次买入，持有15个月，盈利37.9635%</li></ul><pre><code>2008-12-31  1817.72  买入2009-03-31  2507.79  卖出</code></pre><ul><li>第二次买入，持有32个月，盈利64.5752% </li></ul><pre><code>2012-06-29  2461.61  买入2015-03-31  4051.20  卖出</code></pre><ul><li>第三次买入，持有18个月，盈利26.8756% </li></ul><pre><code>2016-01-29  2946.09  买入2017-07-31  3737.87  卖出</code></pre><ul><li>第四次买入，持有23个月，盈利64.7568% </li></ul><pre><code>2018-12-28  3010.65  买入2020-11-30  4960.25  卖出</code></pre><p>年化复合收益率为：策略复合盈亏13.8577256%</p><h3 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h3><p>策略结果略显一般。</p><p>同学们可以修改策略（如标的股、股债比点位），得到更好的回测数据。</p><p>PS：这里我也是说，更好的回测数据，并不是更好的策略。历史数据不代表未来，而且改策略空仓时间较长。我也不能忍住空仓的寂寞。所以在实盘操作时，股债比只是一个参考物，控制手中的仓位。在低谷下跌时，敢于买入并持有；在高估时，减少减低手中的仓位。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 理财 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2020理财年终总结及对2021年的展望</title>
      <link href="2021/01/17/summary2020/"/>
      <url>2021/01/17/summary2020/</url>
      
        <content type="html"><![CDATA[<h2 id="2020年终总结"><a href="#2020年终总结" class="headerlink" title="2020年终总结"></a>2020年终总结</h2><blockquote><p>入市不足一年的小小白</p></blockquote><h3 id="初入市场"><a href="#初入市场" class="headerlink" title="初入市场"></a>初入市场</h3><p>步入资本市场，算是巧合，也是必然。</p><h4 id="必然"><a href="#必然" class="headerlink" title="必然"></a>必然</h4><p>2016年底就职一家期货软件开发公司。为了工作，学过一些股票、期货、期权相关的知识，也参加了期货从业资格证的考试，这都为我入市埋下了伏笔。但是在中国普通老百姓眼里，炒股还是如狼似虎。</p><p>2019年末，公司计划所有员工参加一次期货培训，并且考试通过。</p><p>2020年初，因为疫情，原定的培训只能远程培训了。在接下来的6天培训中，我感觉打开了一扇开往新世界的大门。当时的我，懵懂、好奇、探索欲，充斥着大脑。培训后，我继续着探索，很自然的步入了基金的怀抱。</p><h4 id="巧合"><a href="#巧合" class="headerlink" title="巧合"></a>巧合</h4><p>当时，由于疫情的冲击，美股一周三次熔断，国内股市也比较低迷（因为当时 真•小白 只敢小资金试错，错过买入时机）。入市以后，估价不断上涨（入市后亏损，可能就已经退市了。\手动滑稽），好像市场在给予我鼓励，我也逐渐增加信心，不断的（少量）往基金中加仓，市场不断给我甜枣。</p><h3 id="一次冲动，稀释了大部分收益"><a href="#一次冲动，稀释了大部分收益" class="headerlink" title="一次冲动，稀释了大部分收益"></a>一次冲动，稀释了大部分收益</h3><p>直到，七月初的一周暴力拉升，证券鸡一周受益40%左右。大赚了一把，也把我的理智冲没了。接下来的一周，快速加到了满仓（但是4-5成仓的样子）。很显然，我是加仓在了山顶，七月份有两个交易日亏损超过一万元。一次冲动稀释了我太多收益。</p><h3 id="小插曲"><a href="#小插曲" class="headerlink" title="小插曲"></a>小插曲</h3><p>11月底，我去股市啦。八月份以来，基金基本没有盈利，长时间的横盘，把我的耐心好的差不多了。我想到股市中摸摸鱼。</p><p>12月，股市给了我重大的两耳光——两跌停。一只本应该割的票，由于没有执行力，幻想着今天跌停了，明天涨一点回来能少亏一点（有多少人跟我一样的）。2021年1月，还是它，两个涨停，我给割了。它让我成长，我感谢它。</p><h3 id="年终收益"><a href="#年终收益" class="headerlink" title="年终收益"></a>年终收益</h3><p>接下来，也就没什么好说的了，牛市中，我还是满仓苦苦坚持着。年终收益率，只跑赢了上证指数。</p><p>果然，一顿操作猛如虎，越操作越错。</p><h2 id="2021年展望"><a href="#2021年展望" class="headerlink" title="2021年展望"></a>2021年展望</h2><blockquote><p>我不再是当初的 真•小白 了，已经在市场的毒打中，成长为 小小白 了</p></blockquote><h3 id="对现股市的宏观判断"><a href="#对现股市的宏观判断" class="headerlink" title="对现股市的宏观判断"></a>对现股市的宏观判断</h3><ul><li>人民币持续增值</li><li>破净股比例维持在8%左右</li><li>中证500市盈率正常，但是沪深300市盈率偏高（大佬们说，因为行情不好，收益低，导致市盈率失真）</li><li>A股PE中位数，略高于十年期国债利率倒数</li><li>美国还将持续放水</li><li>AH股溢价，现数据来看，H股更具性价比</li></ul><p>基于以上数据，个人持有偏乐观的态度（借用大佬们的经典语录：明天很大可能上涨，极小的可能下跌，当然，也不排除横盘的可能。）是不是感觉大佬们啥都说了，也啥都没说。所以减少耳边的噪音，很有必要。</p><h3 id="2021年计划"><a href="#2021年计划" class="headerlink" title="2021年计划"></a>2021年计划</h3><ul><li>60%主动基金，卧倒不动，专业的事交给专业的人做。</li><li>30%被动基金，根据一些数据，动态调整。训练对市场的判断，和执行力。</li><li>10%股票，用于打新。训练读财报能力，和执行能力。</li></ul><p>被动基金和股票，是用来试错交学费的，也希望在尽少的亏损，点满每一个技能。</p><p>2021年，我的期望不高，跑赢大盘就行。</p><p>2021。我来了。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>autojs</title>
      <link href="2020/11/03/autojs/"/>
      <url>2020/11/03/autojs/</url>
      
        <content type="html"><![CDATA[<h1 id="auto-js"><a href="#auto-js" class="headerlink" title="auto.js"></a>auto.js</h1><p><a href="https://hyb1996.github.io/AutoJs-Docs/#/">开发文档</a></p><h2 id="1-环境搭建"><a href="#1-环境搭建" class="headerlink" title="1. 环境搭建"></a>1. 环境搭建</h2><ol><li>手机安装auto.js，打开无障碍权限和悬浮窗</li><li>电脑安装vscode，并安装<code>auto.js-vscodeext</code>插件。安装插件后，可使用一下命令：</li></ol><p>按 <code>Ctrl+Shift+P</code> 或点击”查看”-&gt;”命令面板”可调出命令面板，输入 <code>Auto.js</code> 可以看到几个命令：</p><ul><li>Start Server: 启动插件服务。之后在确保手机和电脑在同一区域网的情况下，在Auto.js的侧拉菜单中使用连接电脑功能连接。</li><li>Stop Server: 停止插件服务。</li><li>Run 运行当前编辑器的脚本。如果有多个设备连接，则在所有设备运行。</li><li>Rerun 停止当前文件对应的脚本并重新运行。如果有多个设备连接，则在所有设备重新运行。</li><li>Stop 停止当前文件对应的脚本。如果有多个设备连接，则在所有设备停止。</li><li>StopAll 停止所有正在运行的脚本。如果有多个设备连接，则在所有设备运行所有脚本。</li><li>Save 保存当前文件到手机的脚本默认目录（文件名会加上前缀remote)。如果有多个设备连接，则在所有设备保存。</li><li>RunOnDevice: 弹出设备菜单并在指定设备运行脚本。</li><li>SaveToDevice: 弹出设备菜单并在指定设备保存脚本。</li><li>New Project（新建项目）：选择一个空文件夹（或者在文件管理器中新建一个空文件夹），将会自动创建一个项目</li><li>Run Project（运行项目）：运行一个项目，需要Auto.js 4.0.4Alpha5以上支持</li><li>Save Project（保存项目）：保存一个项目，需要Auto.js 4.0.4Alpha5以上支持</li></ul><ol start="3"><li>启用<code>start server</code>，然后手机连接电脑<code>ip</code>，需要手机和电脑在同一个区域网下。可通过<code>cmd</code>执行<code>ipconfig</code>查看电脑<code>ip</code></li><li>编写脚本，按快捷键<code>F5</code>即可在手机上测试脚本。</li></ol><h2 id="2-开发说明"><a href="#2-开发说明" class="headerlink" title="2. 开发说明"></a>2. 开发说明</h2><h3 id="2-1-定义变量与输出"><a href="#2-1-定义变量与输出" class="headerlink" title="2.1 定义变量与输出"></a>2.1 定义变量与输出</h3><blockquote><p>与es6一致, 不详细列举了</p></blockquote><pre class=" language-javascript"><code class="language-javascript"><span class="token comment" spellcheck="true">// 定义变量</span><span class="token keyword">var</span> str <span class="token operator">=</span> <span class="token string">"我是字符串"</span><span class="token comment" spellcheck="true">// 输出</span><span class="token function">log</span><span class="token punctuation">(</span>str<span class="token punctuation">)</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>str<span class="token punctuation">)</span><span class="token function">toastLog</span><span class="token punctuation">(</span>str<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// 相当于log(str) + toast(str)</span></code></pre><h3 id="2-2-循环"><a href="#2-2-循环" class="headerlink" title="2.2 循环"></a>2.2 循环</h3><blockquote><p>这里也只列举两种特殊点的</p></blockquote><pre class=" language-javascript"><code class="language-javascript"><span class="token comment" spellcheck="true">// 无限循环</span><span class="token keyword">var</span> i <span class="token operator">=</span> <span class="token number">0</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  i <span class="token operator">=</span> i <span class="token operator">+</span> <span class="token number">1</span>  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">==</span> <span class="token number">100</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">break</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">var</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token keyword">switch</span> <span class="token punctuation">(</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token keyword">case</span> <span class="token number">0</span><span class="token punctuation">:</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span>  <span class="token keyword">case</span> <span class="token number">1</span><span class="token punctuation">:</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">}</span></code></pre><h3 id="2-3-设备操作"><a href="#2-3-设备操作" class="headerlink" title="2.3 设备操作"></a>2.3 设备操作</h3><pre class=" language-javascript"><code class="language-javascript">console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>device<span class="token punctuation">)</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>device<span class="token punctuation">.</span><span class="token function">getIMEI</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">//返回设备的IMEI.(没获取到,应该是华为手机的原因)</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>device<span class="token punctuation">.</span><span class="token function">getAndroidId</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">//返回设备的Android ID。</span>device<span class="token punctuation">.</span><span class="token function">keepScreenOn</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">//一直保持屏幕常亮</span>device<span class="token punctuation">.</span><span class="token function">cancelKeepingAwake</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">//来取消屏幕常亮。</span></code></pre><h3 id="2-4-节点操作"><a href="#2-4-节点操作" class="headerlink" title="2.4 节点操作"></a>2.4 节点操作</h3><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">var</span> sendButton <span class="token operator">=</span> <span class="token function">text</span><span class="token punctuation">(</span><span class="token string">"发送"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">findOne</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>sendButton<span class="token punctuation">.</span><span class="token function">click</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>主要还有以下几种属性：</p><ul><li><code>className</code> 类名。类名表示一个控件的类型，例如文本控件为”android.widget.TextView”, 图片控件为”android.widget.ImageView”等。</li><li><code>packageName</code> 包名。包名表示控件所在的应用包名，例如QQ界面的控件的包名为”com.tencent.mobileqq”。</li><li><code>bounds</code> 控件在屏幕上的范围。</li><li><code>drawingOrder</code> 控件在父控件的绘制顺序。</li><li><code>indexInParent</code> 控件在父控件的位置。</li><li><code>clickable</code> 控件是否可点击。</li><li><code>longClickable</code> 控件是否可长按。</li><li><code>checkable</code> 控件是否可勾选。</li><li><code>checked</code> 控件是否可已勾选。</li><li><code>scrollable</code> 控件是否可滑动。</li><li><code>selected</code> 控件是否已选择。</li><li><code>editable</code> 控件是否可编辑。</li><li><code>visibleToUser</code> 控件是否可见。</li><li><code>enabled</code> 控件是否已启用。</li><li><code>depth</code> 控件的布局深度。</li></ul><p> 有时候只靠一个属性并不能唯一确定一个控件，这时需要通过属性的组合来完成定位，例如<code>className("ImageView").depth(10).findOne().click()</code>，通过链式调用来组合条件。 </p><p>对选取的控件进行操作，包括：</p><ul><li><code>click()</code> 点击。点击一个控件，前提是这个控件的clickable属性为true</li><li><code>longClick()</code> 长按。长按一个控件，前提是这个控件的longClickable属性为true</li><li><code>setText()</code> 设置文本，用于编辑框控件设置文本。</li><li><code>scrollForward()</code>, <code>scrollBackward()</code> 滑动。滑动一个控件(列表等), 前提是这个控件的scrollable属性为true</li><li><code>exits()</code> 判断控件是否存在</li><li><code>waitFor()</code> 等待控件出现</li></ul>]]></content>
      
      
      <categories>
          
          <category> 脚本 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> autojs </tag>
            
            <tag> 脚本 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>selenium</title>
      <link href="2020/11/03/selenium/"/>
      <url>2020/11/03/selenium/</url>
      
        <content type="html"><![CDATA[<h1 id="selenium"><a href="#selenium" class="headerlink" title="selenium"></a>selenium</h1><blockquote><p> 作用于自动化测试和爬虫</p></blockquote><p>谈到自动化测试，就不得不提的一个人和概念就是：Martin Fowler和他的金字塔原理。首先请看金字塔原理的图示如下：</p><p><img src="https://pic.downk.cc/item/5fb0125fb3cdc49425e29975.png" alt="金字塔原理"></p><p>该图说明了三个问题：</p><ul><li>自动化测试包括三个方面：UI前端界面，Service服务契约和Unit底层单元</li><li>越是底层的测试，运行速度越快，时间开销越少，金钱开销越少</li><li>越是顶层的测试，运行速度越慢，时间开销越多，金钱开销越多</li></ul><p>这是理想中的金字塔原理。</p><h2 id="1-Selenium-基本介绍"><a href="#1-Selenium-基本介绍" class="headerlink" title="1. Selenium 基本介绍"></a>1. Selenium 基本介绍</h2><p>Selenium`是开源的自动化测试工具，它主要是用于Web 应用程序的自动化测试，不只局限于此，同时支持所有基于web 的管理任务自动化。</p><ul><li><p><code>Selenium</code>官网的介绍</p><blockquote><p>Selenium is a suite of tools to automate web browsers across many platforms.</p><ul><li>runs in many browsers and operating systems</li><li>can be controlled by many programming languages and testing frameworks.</li></ul></blockquote><ul><li>Selenium 官网：<a href="https://link.jianshu.com/?t=http://seleniumhq.org/">http://seleniumhq.org/</a></li><li>Selenium Github 主页：<a href="https://link.jianshu.com/?t=https://github.com/SeleniumHQ/selenium">https://github.com/SeleniumHQ/selenium</a></li></ul><p><a href="https://link.jianshu.com/?t=https://www.continuum.io/anaconda-overview">https://link.jianshu.com/?t=https%3A%2F%2Fwww.continuum.io%2Fanaconda-overview</a>)</p></li><li><p>安装 Selenium 工具包</p><pre><code>pip install selenium</code></pre></li><li><p>配置 浏览器 和 驱动</p><ul><li>配置Windows浏览器 和 驱动<ul><li>下载ChromeDriver：<a href="https://link.jianshu.com/?t=http://chromedriver.storage.googleapis.com/index.html">http://chromedriver.storage.googleapis.com/index.html</a></li><li>下载geckodriver.exe：<a href="https://github.com/mozilla/geckodriver/releases">下载地址</a></li><li>下载解压后将getckodriver.exe复制到Firefox的安装目录下，并在环境变量Path中添加路径</li></ul></li><li>配置ubuntu浏览器 和 驱动<ul><li>下载ChromeDriver：<a href="https://link.jianshu.com/?t=http://chromedriver.storage.googleapis.com/index.html">http://chromedriver.storage.googleapis.com/index.html</a></li><li>下载geckodriver.exe：<a href="https://github.com/mozilla/geckodriver/releases">下载地址</a></li><li>解压后将geckodriverckod 存放至 /usr/local/bin/ 路径下即可</li></ul></li></ul></li></ul><h2 id="2-Selenium-的使用"><a href="#2-Selenium-的使用" class="headerlink" title="2. Selenium 的使用"></a>2. Selenium 的使用</h2><h3 id="2-1-Selenium-的最简脚本"><a href="#2-1-Selenium-的最简脚本" class="headerlink" title="2.1 Selenium 的最简脚本"></a>2.1 Selenium 的最简脚本</h3><p>通过上一节的环境安装成功以后，我们可以进行第一个对Selenium 的使用，就是最简脚本编写。脚本如下：</p><pre class=" language-Python"><code class="language-Python"># 声明driver = webdriver.Chrome() # 加载一个网页driver.get("https://github.com/") sleep(3) # 开始登录we_account = driver.find_element_by_css_selector('#account')we_account.clear()we_account.send_keys("demo") we_password = driver.find_element_by_css_selector('#password')we_password.clear()we_password.send_keys("demo") driver.find_element_by_css_selector('#submit').click()sleep(3)</code></pre><ul><li>clear()：清理页面元素中的文字</li><li>send_keys(text)：给页面元素中，输入新的文字</li><li>click()：鼠标左键点击页面元素</li><li>get_attribute(‘text’)：获取标签中的文字</li><li>定位</li></ul><pre class=" language-Python"><code class="language-Python">imgelement = self.browser.find_element_by_id('authImg')# 获取x,y坐标location = imgelement.locationx = location['x']y = location['y']# 获取尺寸size = imgelement.sizewidth = size['width']height = size['height']</code></pre><ul><li>等待节点加载完成</li></ul><pre class=" language-Python"><code class="language-Python">WebDriverWait(browser,超时时间)# 1. until(method,message)  用于等待某个节点加载完成WebDriverWait(browser, 600000).until(EC.presence_of_element_located((By.ID, 'id')))# 2. until_not(method,message)  用于等待某个节点消失，或条件不成立。WebDriverWait(browser, 600000).until_not(EC.presence_of_element_located((By.NAME, 'name')))</code></pre><p><code>until_not</code>可用于打码时, 判断验证码是否成功</p><p>判断验证码是否成功的另两个办法。推荐方法二</p><ol><li>方法一, 判断是否弹出错误信息</li></ol><pre class=" language-python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">isElementExist</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>    flag <span class="token operator">=</span> <span class="token boolean">True</span>    <span class="token keyword">try</span><span class="token punctuation">:</span>        self<span class="token punctuation">.</span>browser<span class="token punctuation">.</span>find_element_by_class_name<span class="token punctuation">(</span><span class="token string">'验证错误时的提示信息'</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> flag    <span class="token keyword">except</span><span class="token punctuation">:</span>        flag <span class="token operator">=</span> <span class="token boolean">False</span>        <span class="token keyword">return</span> flag<span class="token keyword">def</span> <span class="token function">searchPage</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> shenqingh<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token triple-quoted-string string">'''    验证逻辑省略...    '''</span>    <span class="token comment" spellcheck="true"># 循环判断, 验证码是否识别成功</span>    <span class="token keyword">if</span> self<span class="token punctuation">.</span>isElementExist<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>        self<span class="token punctuation">.</span>searchPage<span class="token punctuation">(</span>shenqingh<span class="token punctuation">)</span></code></pre><ol start="2"><li>方法二, 判断是否出现成功后的节点。</li></ol><pre class=" language-Python"><code class="language-Python">def isElementExist(self):    flag = True    try:        WebDriverWait(self.browser, 5).until(EC.presence_of_element_located((By.NAME, '成功后应该出现的name')))        return flag    except:        flag = False        return flagdef searchPage(self, shenqingh):    '''    验证逻辑省略...    '''    # 循环判断, 是否识别成功    if not self.isElementExist():        self.searchPage(shenqingh)</code></pre><h3 id="2-2-Selenium-WebDriver-API-的使用"><a href="#2-2-Selenium-WebDriver-API-的使用" class="headerlink" title="2.2 Selenium WebDriver API 的使用"></a>2.2 Selenium WebDriver API 的使用</h3><p>Selenium WebDriver API 官方参考：<a href="https://link.jianshu.com/?t=http://seleniumhq.github.io/selenium/docs/api/py/">http://seleniumhq.github.io/selenium/docs/api/py/</a></p><p>具体API文档地址：<a href="https://link.jianshu.com/?t=https://seleniumhq.github.io/selenium/docs/api/py/api.html">https://seleniumhq.github.io/selenium/docs/api/py/api.html</a></p><ul><li>API 使用： 用现成的类（大部分情况）的方法进行编程<ul><li>WebDriver</li><li>WebElement</li></ul></li><li>API 文档<ul><li>编程使用说明</li><li>介绍了每个方法的使用<ul><li>方法的作用</li><li>方法的参数</li><li>方法的返回值</li></ul></li></ul></li></ul><h4 id="2-2-1-控制浏览器"><a href="#2-2-1-控制浏览器" class="headerlink" title="2.2.1 控制浏览器"></a>2.2.1 控制浏览器</h4><p>浏览器的控制也是自动化测试的一个基本组成部分，我们可以将浏览器最大化，设置浏览器的高度和宽度以及对浏览器进行导航操作等。</p><pre class=" language-python"><code class="language-python"><span class="token comment" spellcheck="true"># 浏览器打开网址</span>driver<span class="token punctuation">.</span>get<span class="token punctuation">(</span><span class="token string">"https://www.baidu.com"</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true"># 浏览器最大化</span>driver<span class="token punctuation">.</span>maximize_window<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true"># 设置浏览器的高度为800像素，宽度为480像素</span>driver<span class="token punctuation">.</span>set_window_size<span class="token punctuation">(</span><span class="token number">480</span><span class="token punctuation">,</span> <span class="token number">800</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true"># 浏览器后退</span>driver<span class="token punctuation">.</span>back<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true"># 浏览器前进</span>driver<span class="token punctuation">.</span>forward<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true"># 浏览器关闭</span>driver<span class="token punctuation">.</span>close<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true"># 浏览器退出</span>driver<span class="token punctuation">.</span>quit<span class="token punctuation">(</span><span class="token punctuation">)</span></code></pre><h4 id="2-2-2-元素定位操作"><a href="#2-2-2-元素定位操作" class="headerlink" title="2.2.2 元素定位操作"></a>2.2.2 元素定位操作</h4><p>WebDriver提供了一系列的定位符以便使用元素定位方法。常见的定位符有以下几种：</p><ul><li>id</li><li>name</li><li>class name</li><li>tag</li><li>link text</li><li>partial link text</li><li>xpath</li><li>css selector</li></ul><p>WebDriver提供了多种多样的<code>find_element_by</code>方法在一个网页里面查找元素。也提供了<code>find_elements_by</code>的方式去定位多个元素。</p><p>尽管上述的方式，可以进行元素定位，实际上我们也是更多的用组合的方式进行元素定位。</p><table><thead><tr><th align="left">方法Method</th><th align="left">参数Argument</th><th align="left">示例Example</th></tr></thead><tbody><tr><td align="left"><code>id</code></td><td align="left">id: 需要被查找的元素的ID</td><td align="left"><code>find_element_by_id('search')</code></td></tr><tr><td align="left"><code>name</code></td><td align="left">name: 需要被查找的元素的名称</td><td align="left"><code>find_element_by_name('q')</code></td></tr><tr><td align="left"><code>class name</code></td><td align="left">class_name: 需要被查找的元素的类名</td><td align="left"><code>find_element_by_class_name('input-text')</code></td></tr><tr><td align="left"><code>tag_name</code></td><td align="left">tag: 需要被查找的元素的标签名称</td><td align="left"><code>find_element_by_tag_name('input')</code></td></tr><tr><td align="left"><code>link_text</code></td><td align="left">link_text: 需要被查找的元素的链接文字</td><td align="left"><code>find_element_by_link_text('Log In')</code></td></tr><tr><td align="left"><code>partial_link_text</code></td><td align="left">link_text: 需要被查找的元素的部分链接文字</td><td align="left"><code>find_element_by_partial_link_text('Long')</code></td></tr><tr><td align="left"><code>xpath</code></td><td align="left">xpath: 需要被查找的元素的xpath</td><td align="left"><code>find_element_by_xpath('//*[@id="xx"]/a')</code></td></tr><tr><td align="left"><code>css_selector</code></td><td align="left">css_selector: 需要被查找的元素的ID</td><td align="left"><code>find_element_by_css_selector('#search')</code></td></tr></tbody></table><p>链接文字查找通常比较简单。使用<code>find_element_by_link_text</code>请查看以下示例</p><pre class=" language-javascript"><code class="language-javascript"><span class="token operator">&lt;</span>a href<span class="token operator">=</span><span class="token string">"#header-account"</span> <span class="token keyword">class</span><span class="token operator">=</span><span class="token string">"skip-link skip-account"</span><span class="token operator">></span>        <span class="token operator">&lt;</span>span <span class="token keyword">class</span><span class="token operator">=</span><span class="token string">"icon"</span><span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">/</span>span<span class="token operator">></span>        <span class="token operator">&lt;</span>span <span class="token keyword">class</span><span class="token operator">=</span><span class="token string">"label"</span><span class="token operator">></span>ACCOUNT Description<span class="token operator">&lt;</span><span class="token operator">/</span>span<span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">/</span>a<span class="token operator">></span></code></pre><p>测试代码如下：</p><pre class=" language-Python"><code class="language-Python">self.driver.find_element_by_link_text("ACCOUNT Description")</code></pre><p>依据部分链接文字partial text查找</p><pre class=" language-Python"><code class="language-Python">self.driver.find_elements_by_partial_link_text("ACCOUNT")</code></pre><p>依据XPath进行查找</p><p>常用的XPath的方法有<code>starts-with()</code>，<code>contains()</code>和<code>ends-with()</code>等</p><blockquote><p>若想要了解更多关于XPath的内容，请查看<a href="https://link.jianshu.com/?t=http://www.w3schools.com/XPath/">http://www.w3schools.com/XPath/</a></p></blockquote><h4 id="2-2-3-鼠标事件操作"><a href="#2-2-3-鼠标事件操作" class="headerlink" title="2.2.3 鼠标事件操作"></a>2.2.3 鼠标事件操作</h4><p>常用的鼠标方法：</p><ul><li>context_click() # 右击</li><li>double_click() # 双击</li><li>drag_and_drop() # 拖拽</li><li>move_to_element() # 鼠标停在一个元素上</li><li>click_and_hold() # 按下鼠标左键在一个元素上</li></ul><h4 id="2-2-4-键盘事件操作"><a href="#2-2-4-键盘事件操作" class="headerlink" title="2.2.4 键盘事件操作"></a>2.2.4 键盘事件操作</h4><p>键盘操作经常处理的如下：</p><table><thead><tr><th align="left">代码</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left"><code>send_keys(Keys.BACKSPACE)</code></td><td align="left">删除键(BackSpace)</td></tr><tr><td align="left"><code>send_keys(Keys.SPACE)</code></td><td align="left">空格键(Space)</td></tr><tr><td align="left"><code>send_keys(Keys.TAB)</code></td><td align="left">制表键(Tab)</td></tr><tr><td align="left"><code>send_keys(Keys.ESCAPE)</code></td><td align="left">回退键(Esc)</td></tr><tr><td align="left"><code>send_keys(Keys.ENTER)</code></td><td align="left">回车键(Enter)</td></tr><tr><td align="left"><code>send_keys(Keys.CONTROL,'a')</code></td><td align="left">全选（Ctrl+A）</td></tr><tr><td align="left"><code>send_keys(Keys.CONTROL,'c')</code></td><td align="left">复制（Ctrl+C）</td></tr></tbody></table><p><strong>PS：</strong>selenium操作的是相对上一次的坐标，所以根据不同的需求，需要做一定的封装</p><pre class=" language-Python"><code class="language-Python">from selenium.webdriver.common.action_chains import ActionChainsdef click_locxy(dr, x, y, left_click=True):    '''    dr:浏览器    x:页面x坐标    y:页面y坐标    left_click:True为鼠标左键点击，否则为右键点击    '''    if left_click:        ActionChains(dr).move_by_offset(x, y).click().perform()    else:        ActionChains(dr).move_by_offset(x, y).context_click().perform()    ActionChains(dr).move_by_offset(-x, -y).perform()  # 将鼠标位置恢复到移动前</code></pre><h4 id="2-2-5-截图操作"><a href="#2-2-5-截图操作" class="headerlink" title="2.2.5 截图操作"></a>2.2.5 截图操作</h4><pre class=" language-python"><code class="language-python">self<span class="token punctuation">.</span>browser<span class="token punctuation">.</span>save_screenshot<span class="token punctuation">(</span><span class="token string">'verificationCode.png'</span><span class="token punctuation">)</span></code></pre><ul><li>截小图</li></ul><p>在图片的基础上截取, 可使用<code>PIL</code>模块</p><pre class=" language-Python"><code class="language-Python">from PIL import Imageimageopen = Image.open('printscreen.png')# 设定要截取的位置,这里是个元组# (左, 上, 右, 下)rangle = (623, 364, 685, 396)frame4 = imageopen.crop(rangle)frame4.save('code.jpg')</code></pre><h2 id="3-数据库相关操作"><a href="#3-数据库相关操作" class="headerlink" title="3. 数据库相关操作"></a>3. 数据库相关操作</h2><h3 id="3-1-MySQL"><a href="#3-1-MySQL" class="headerlink" title="3.1 MySQL"></a>3.1 MySQL</h3><pre class=" language-python"><code class="language-python"><span class="token keyword">import</span> pymysqlconnect <span class="token operator">=</span> pymysql<span class="token punctuation">.</span>connect<span class="token punctuation">(</span>host<span class="token operator">=</span><span class="token string">"xx"</span><span class="token punctuation">,</span> port<span class="token operator">=</span><span class="token number">3306</span><span class="token punctuation">,</span> user<span class="token operator">=</span><span class="token string">"root"</span><span class="token punctuation">,</span> passwd<span class="token operator">=</span><span class="token string">"xxx"</span><span class="token punctuation">,</span> db<span class="token operator">=</span><span class="token string">"xx"</span><span class="token punctuation">)</span>cur <span class="token operator">=</span> connect<span class="token punctuation">.</span>cursor<span class="token punctuation">(</span><span class="token punctuation">)</span>cur<span class="token punctuation">.</span>execute<span class="token punctuation">(</span><span class="token string">"SELECT..."</span><span class="token punctuation">)</span>mysql_data <span class="token operator">=</span> cur<span class="token punctuation">.</span>fetchall<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">for</span> row <span class="token keyword">in</span> mysql_data<span class="token punctuation">:</span>    <span class="token comment" spellcheck="true"># 进行测试</span>    <span class="token comment" spellcheck="true"># 使用字典类型</span>    data_to_test <span class="token operator">=</span> <span class="token punctuation">{</span>      <span class="token string">"key1"</span><span class="token punctuation">:</span> row<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span>      <span class="token string">"key2"</span><span class="token punctuation">:</span> row<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span>    <span class="token punctuation">}</span>cur<span class="token punctuation">.</span>close<span class="token punctuation">(</span><span class="token punctuation">)</span>connect<span class="token punctuation">.</span>close<span class="token punctuation">(</span><span class="token punctuation">)</span></code></pre><h3 id="3-2-Oracle"><a href="#3-2-Oracle" class="headerlink" title="3.2 Oracle"></a>3.2 Oracle</h3><pre class=" language-Python"><code class="language-Python">import cx_Oracle os.environ['NLS_LANG'] = 'SIMPLIFIED CHINESE_CHINA.UTF8'        # 解决中文乱码问题# 连接 user/passwd@host:端口/instanceconn = cx_Oracle.connect('user/passwd@host:port/sm2')# 创建游标对象c = conn.cursor()# 执行命令x = c.execute('select sysdate from dual')# data = x.fetchone()       # 返回单个元组，如果查询不到结果，则返回None(也就是只返回一条数据)# print(data)self.data = x.fetchall()         # 返回二维元组，如果查询不到结果，则返回()# print(data)# 关闭游标对象c.close()# 关闭连接conn.close()</code></pre>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 爬虫 </tag>
            
            <tag> 自动化测试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>简历</title>
      <link href="2020/10/31/resume/"/>
      <url>2020/10/31/resume/</url>
      
        <content type="html"><![CDATA[<h1 id="联系方式"><a href="#联系方式" class="headerlink" title="联系方式"></a>联系方式</h1><p>（HR会打印你的简历，用于在面试的时候联系，所以联系方式放到最上边会比较方便）</p><ul><li>手机：135…. （如果是外地手机，可注明。如经常关机，要写上最优联系时间）</li><li>Email：<a href="mailto:goodman@gmail.com">goodman@gmail.com</a> （虽然我觉得QQ邮箱无所谓，不过有些技术人员比较反感，建议用G，非要用的话，不要用数字邮箱名）</li><li>QQ/微信号：6…（提供一个通过网络可以联系到你的方式）</li></ul><h1 id="个人信息"><a href="#个人信息" class="headerlink" title="个人信息"></a>个人信息</h1><ul><li><p>冷熊/男/1990 </p></li><li><p>本科/北极大学计算机系 </p></li><li><p>工作年限：3年</p></li><li><p>微博：<a href="http://weibo.com/easy">@Easy</a> （如果没有技术相关内容，也可以不放）</p></li><li><p>技术博客：<a href="http://old.ftqq.com/">http://old.ftqq.com</a> ( 使用GitHub Host的Big较高  )</p></li><li><p>Github：<a href="http://github.com/easychen">http://github.com/easychen</a> ( 有原创repo的Github帐号会极大的提升你的个人品牌  )</p></li><li><p>期望职位：PHP高级程序员，应用架构师</p></li><li><p>期望薪资：税前月薪15k~20k，特别喜欢的公司可例外</p></li><li><p>期望城市：北京</p></li></ul><h1 id="工作经历"><a href="#工作经历" class="headerlink" title="工作经历"></a>工作经历</h1><p>（工作经历按逆序排列，最新的在最前边，按公司做一级分组，公司内按二级分组）</p><h2 id="ABC公司-（-2012年9月-2014年9月-）"><a href="#ABC公司-（-2012年9月-2014年9月-）" class="headerlink" title="ABC公司 （ 2012年9月 ~ 2014年9月 ）"></a>ABC公司 （ 2012年9月 ~ 2014年9月 ）</h2><h3 id="DEF项目"><a href="#DEF项目" class="headerlink" title="DEF项目"></a>DEF项目</h3><p>我在此项目负责了哪些工作，分别在哪些地方做得出色/和别人不一样/成长快，这个项目中，我最困难的问题是什么，我采取了什么措施，最后结果如何。这个项目中，我最自豪的技术细节是什么，为什么，实施前和实施后的数据对比如何，同事和领导对此的反应如何。</p><h3 id="GHI项目"><a href="#GHI项目" class="headerlink" title="GHI项目"></a>GHI项目</h3><p>我在此项目负责了哪些工作，分别在哪些地方做得出色/和别人不一样/成长快，这个项目中，我最困难的问题是什么，我采取了什么措施，最后结果如何。这个项目中，我最自豪的技术细节是什么，为什么，实施前和实施后的数据对比如何，同事和领导对此的反应如何。</p><h3 id="其他项目"><a href="#其他项目" class="headerlink" title="其他项目"></a>其他项目</h3><p>（每个公司写2~3个核心项目就好了，如果你有非常大量的项目，那么按分类进行合并，每一类选一个典型写出来。其他的一笔带过即可。）</p><h2 id="JKL公司-（-2010年3月-2012年8月-）"><a href="#JKL公司-（-2010年3月-2012年8月-）" class="headerlink" title="JKL公司 （ 2010年3月 ~ 2012年8月 ）"></a>JKL公司 （ 2010年3月 ~ 2012年8月 ）</h2><h3 id="MNO项目"><a href="#MNO项目" class="headerlink" title="MNO项目"></a>MNO项目</h3><p>我在此项目负责了哪些工作，分别在哪些地方做得出色/和别人不一样/成长快，这个项目中，我最困难的问题是什么，我采取了什么措施，最后结果如何。这个项目中，我最自豪的技术细节是什么，为什么，实施前和实施后的数据对比如何，同事和领导对此的反应如何。</p><h3 id="PQR项目"><a href="#PQR项目" class="headerlink" title="PQR项目"></a>PQR项目</h3><p>我在此项目负责了哪些工作，分别在哪些地方做得出色/和别人不一样/成长快，这个项目中，我最困难的问题是什么，我采取了什么措施，最后结果如何。这个项目中，我最自豪的技术细节是什么，为什么，实施前和实施后的数据对比如何，同事和领导对此的反应如何。</p><h3 id="其他项目-1"><a href="#其他项目-1" class="headerlink" title="其他项目"></a>其他项目</h3><p>（每个公司写2~3个核心项目就好了，如果你有非常大量的项目，那么按分类进行合并，每一类选一个典型写出来。其他的一笔带过即可。）</p><h1 id="开源项目和作品"><a href="#开源项目和作品" class="headerlink" title="开源项目和作品"></a>开源项目和作品</h1><p>（这一段用于放置工作以外的、可证明你的能力的材料）</p><h2 id="开源项目"><a href="#开源项目" class="headerlink" title="开源项目"></a>开源项目</h2><p>（对于程序员来讲，没有什么比Show me the code能有说服力了）</p><ul><li><a href="http://github.com/yourname/projectname">STU</a>：项目的简要说明，Star和Fork数多的可以注明</li><li><a href="http://github.com/yourname/projectname">WXYZ</a>：项目的简要说明，Star和Fork数多的可以注明</li></ul><h2 id="技术文章"><a href="#技术文章" class="headerlink" title="技术文章"></a>技术文章</h2><p>（挑选你写作或翻译的技术文章，好的文章可以从侧面证实你的表达和沟通能力，也帮助招聘方更了解你）</p><ul><li><a href="http://get.jobdeer.com/706.get">一个产品经理眼中的云计算：前生今世和未来</a></li><li><a href="http://get.jobdeer.com/343.get">来自HeroKu的HTTP API 设计指南(翻译文章)</a> （ 好的翻译文章可以侧证你对英文技术文档的阅读能力）</li></ul><h2 id="演讲和讲义"><a href="#演讲和讲义" class="headerlink" title="演讲和讲义"></a>演讲和讲义</h2><p>（放置你代表公司在一些技术会议上做过的演讲，以及你在公司分享时制作的讲义）</p><ul><li>2014架构师大会演讲：<a href="http://ftqq.com/">如何通过Docker优化内部开发</a></li><li>9月公司内部分享：<a href="http://ftqq.com/">云计算的前生今世</a></li></ul><h1 id="技能清单"><a href="#技能清单" class="headerlink" title="技能清单"></a>技能清单</h1><p>（我一般主张将技能清单写入到工作经历里边去。不过很难完整，所以有这么一段也不错）</p><p>以下均为我熟练使用的技能</p><ul><li>Web开发：PHP/Hack/Node</li><li>Web框架：ThinkPHP/Yaf/Yii/Lavarel/LazyPHP</li><li>前端框架：Bootstrap/AngularJS/EmberJS/HTML5/Cocos2dJS/ionic</li><li>前端工具：Bower/Gulp/SaSS/LeSS/PhoneGap</li><li>数据库相关：MySQL/PgSQL/PDO/SQLite</li><li>版本管理、文档和自动化部署工具：Svn/Git/PHPDoc/Phing/Composer</li><li>单元测试：PHPUnit/SimpleTest/Qunit</li><li>云和开放平台：SAE/BAE/AWS/微博开放平台/微信应用开发</li></ul><h1 id="技能清单-1"><a href="#技能清单-1" class="headerlink" title="技能清单"></a>技能清单</h1><p>（我一般主张将技能清单写入到工作经历里边去。不过很难完整，所以有这么一段也不错）</p><p>以下均为我熟练使用的技能</p><ul><li>Web开发：PHP/Hack/Node</li><li>Web框架：ThinkPHP/Yaf/Yii/Lavarel/LazyPHP</li><li>前端框架：Bootstrap/AngularJS/EmberJS/HTML5/Cocos2dJS/ionic</li><li>前端工具：Bower/Gulp/SaSS/LeSS/PhoneGap</li><li>数据库相关：MySQL/PgSQL/PDO/SQLite</li><li>版本管理、文档和自动化部署工具：Svn/Git/PHPDoc/Phing/Composer</li><li>单元测试：PHPUnit/SimpleTest/Qunit</li><li>云和开放平台：SAE/BAE/AWS/微博开放平台/微信应用开发</li></ul><hr><h1 id="致谢"><a href="#致谢" class="headerlink" title="致谢"></a>致谢</h1><p>感谢您花时间阅读我的简历，期待能有机会和您共事。</p>]]></content>
      
      
      <categories>
          
          <category> 其他 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 简历 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo</title>
      <link href="2020/10/26/hexo/"/>
      <url>2020/10/26/hexo/</url>
      
        <content type="html"><![CDATA[<h1 id="HEXO"><a href="#HEXO" class="headerlink" title="HEXO"></a>HEXO</h1><blockquote><p>HEXO 是一个搭建静态博客的工具，可一键使<code>Markdown</code>生成为<code>HTML</code>文件, 并生成相应的文章目录/列表/标签/分类等内容. </p></blockquote><p><a href="https://hexo.io/zh-cn/">官网</a></p><h2 id="1-hexo搭建blog"><a href="#1-hexo搭建blog" class="headerlink" title="1. hexo搭建blog"></a>1. hexo搭建blog</h2><h3 id="1-1-安装node-js"><a href="#1-1-安装node-js" class="headerlink" title="1.1 安装node.js"></a>1.1 安装node.js</h3><p>下载地址：</p><pre><code>https://nodejs.org/en/</code></pre><p>验证安装成功</p><pre><code>node -v</code></pre><h3 id="1-2-安装hexo"><a href="#1-2-安装hexo" class="headerlink" title="1.2 安装hexo"></a>1.2 安装hexo</h3><pre><code>npm install -g hexo-cli</code></pre><p>验证安装成功</p><pre><code>hexo -v</code></pre><p><strong>安装时显示成功了，但是执行<code>hexo -v</code>,提示”在此系统上禁止运行脚本”</strong></p><p>解决方法：</p><ol><li>以管理员身份运行vscode;</li><li>执行：get-ExecutionPolicy，显示Restricted，表示状态是禁止的;</li><li>执行：set-ExecutionPolicy RemoteSigned;</li><li>这时再执行get-ExecutionPolicy，就显示RemoteSigned;</li></ol><ul><li>hexo初始化blog</li></ul><pre><code>hexo init</code></pre><p>如果是下载已有的hexo模板,则执行不执行<code>hexo init</code>,执行<code>npm install --force</code>或者<code>npm i</code>或者<code>npm install</code>即可. 会生成<code>node_modules</code>. </p><ul><li>启动本地blog</li></ul><pre><code>hexo s</code></pre><p><code>hexo s</code>是<code>hexo server</code>的缩写</p><p>使用<code>http://localhost:4000</code>访问本地blog</p><p>此时blog就搭建好了. </p><h2 id="2-hexo的基本使用"><a href="#2-hexo的基本使用" class="headerlink" title="2. hexo的基本使用"></a>2. hexo的基本使用</h2><h3 id="2-1-新建文件夹"><a href="#2-1-新建文件夹" class="headerlink" title="2.1 新建文件夹"></a>2.1 新建文件夹</h3><pre><code>hexo new page '文件夹名'</code></pre><p>会在<code>source</code>下生成你创建的<code>文件夹名</code>, 并在该文件夹下生成一个<code>index.md</code>的空文件</p><h3 id="2-2-新建文件"><a href="#2-2-新建文件" class="headerlink" title="2.2 新建文件"></a>2.2 新建文件</h3><pre><code>hexo new '文件名'</code></pre><p>会在<code>source/_posts</code>下生成你创建的<code>文件名.md</code></p><h3 id="2-3-提交代码"><a href="#2-3-提交代码" class="headerlink" title="2.3 提交代码"></a>2.3 提交代码</h3><ul><li>md文件生成静态HTML文件</li></ul><pre><code>hexo clhexo g</code></pre><p>先删除以前生成的HTML文件, 再生成新的HTML文件.</p><p> <code>hexo cl</code>是<code>hexo clean</code>的缩写.  </p><p><code>hexo g</code>是<code>hexo generate</code>的缩写</p><ul><li>将已生成的HTML文件部署到gitee或github上</li></ul><p>部署之前, 安装<code>hexo-deployer-git</code></p><pre><code>npm install --save hexo-deployer-git</code></pre><p>配置<code>_config.yml</code>上传地址:</p><pre><code>deploy:  type: 'git'  repository:    gitee: https://gitee.com/h520522/h520522.git    github: https://github.com/h521822/h521822.github.io.git  branch: master</code></pre><p>可同时配置多个地址</p><p>执行一下命令，完成部署</p><pre><code>hexo d</code></pre><p><code>hexo d</code>是<code>hexo delpoy</code>的缩写</p><h2 id="3-修改主题"><a href="#3-修改主题" class="headerlink" title="3. 修改主题"></a>3. 修改主题</h2><p>可先预览一下笔者使用的<a href="https://h521822.github.io/">博客</a>. </p><p>笔者使用的是<a href="https://github.com/blinkfox/hexo-theme-matery">Matery</a>主题. </p><h3 id="3-1-修改步骤"><a href="#3-1-修改步骤" class="headerlink" title="3.1 修改步骤"></a>3.1 修改步骤</h3><p>下载该主题, 放在<code>themes</code>下, 修改配置文件<code>_config.yml</code>的<code>theme</code>为<code>hexo-theme-matery</code></p><p>然后可以根据<a href="https://github.com/blinkfox/hexo-theme-matery/blob/develop/README_CN.md">文档</a>配置. </p><p>笔者的<a href="https://github.com/h521822/h521822.github.io">配置</a>, 仅供参考. </p>]]></content>
      
      
      <categories>
          
          <category> 其他 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Git学习笔记</title>
      <link href="2020/10/26/git/"/>
      <url>2020/10/26/git/</url>
      
        <content type="html"><![CDATA[<h1 id="Git学习笔记"><a href="#Git学习笔记" class="headerlink" title="Git学习笔记"></a>Git学习笔记</h1><hr><h2 id="1-Git简介"><a href="#1-Git简介" class="headerlink" title="1. Git简介"></a>1. Git简介</h2><ul><li>Git是分布式版本控制系统</li><li>集中式VS分布式：  </li></ul><ol><li>集中式版本控制系统，版本库集中存放在中央服务器，必须要联网才能工作,没有历史版本库。   </li><li>分布式版本控制系统，没有“中央服务器”，每个开发人员电脑上都有一个完整的版本库。  </li><li>分布式优势：安全性更高，无需联网，若“中央服务器”故障，任何一个其他开发者本地都有最新的带历史记录的版本库。  </li><li>主要区别在于历史版本库的存放，集中式历史版本只存在于中央服务器，而分布式中每个本地库都有历史记录存放。</li></ol><h2 id="2-安装Git"><a href="#2-安装Git" class="headerlink" title="2. 安装Git"></a>2. 安装Git</h2><ul><li>Linux系统  </li></ul><p>Debian或Ubuntu Linux</p><pre class=" language-shell"><code class="language-shell">sudo apt-get install git</code></pre><p>老版本Debian或Ubuntu Linux</p><pre class=" language-shell"><code class="language-shell">sudo apt-get install git-core</code></pre><p>其他版本Linux，官网下载源码解压，然后依次输入</p><pre class=" language-shell"><code class="language-shell">./config ——> make ——> sudo make install</code></pre><ul><li>Windows系统  </li></ul><p><a href="https://git-scm.com/downloads">官网下载</a>，安装完成后，“Git”-&gt;“Git Bash”即可打开</p><h3 id="2-1-Git配置"><a href="#2-1-Git配置" class="headerlink" title="2.1 Git配置"></a>2.1 Git配置</h3><pre class=" language-shell"><code class="language-shell">$ git config user.name 查看用户名$ git config user.email 查看邮箱$ git config --global user.name "Your Name"        设置用户名$ git config --global user.email "email@example.com"        设置邮箱</code></pre><p><strong>注意</strong>  <code>--global</code>参数表示你这台机器上所有的Git仓库都会使用这个配置。</p><h1 id="Git命令"><a href="#Git命令" class="headerlink" title="Git命令"></a>Git命令</h1><hr><h2 id="3-创建版本库"><a href="#3-创建版本库" class="headerlink" title="3. 创建版本库"></a>3. 创建版本库</h2><h3 id="3-1-选择一个合适目录"><a href="#3-1-选择一个合适目录" class="headerlink" title="3.1 选择一个合适目录"></a>3.1 选择一个合适目录</h3><p>Windows系统请确保目录名（包括父目录）不包含中文</p><ol><li>如<code>$ cd d:</code></li><li><code>$ mkdir &lt;repository-name&gt;</code>，创建库名</li><li><code>$ cd &lt;repository-name&gt;</code>，进入库内  </li></ol><p><strong>补充</strong>  <code>pwd</code>显示路径，<code>ls</code>显示当前目录，<code>ls -ah</code>显示隐藏目录</p><h3 id="3-2-在当前目录初始化库"><a href="#3-2-在当前目录初始化库" class="headerlink" title="3.2 在当前目录初始化库"></a>3.2 在当前目录初始化库</h3><pre class=" language-shell"><code class="language-shell">$ git init</code></pre><h2 id="4-使用vi编辑器"><a href="#4-使用vi编辑器" class="headerlink" title="4. 使用vi编辑器"></a>4. 使用vi编辑器</h2><ol><li><code>$ vi &lt;file-name&gt;</code>，新建或修改文件</li><li>按<code>i</code>进入编辑</li><li>编辑完成后按<code>ESC</code>，然后选择以下某个命令输入</li></ol><table><thead><tr><th>命令</th><th>效果</th></tr></thead><tbody><tr><td><code>:w</code></td><td>保存文件，不退出vi</td></tr><tr><td><code>:w &lt;file-name&gt;</code></td><td>另存为file,不退出</td></tr><tr><td><code>:w!</code></td><td>强制保存，不退出</td></tr><tr><td><code>:wq</code></td><td>保存文件，退出</td></tr><tr><td><code>:wq!</code></td><td>强制保存，退出</td></tr><tr><td><code>:q</code></td><td>不保存，退出</td></tr><tr><td><code>:q!</code></td><td>不保存，强制退出</td></tr><tr><td><code>:e!</code></td><td>放弃所有修改，回到上次保存文件开始编辑</td></tr></tbody></table><p>查看文件内容</p><pre class=" language-shell"><code class="language-shell">cat <file-name></code></pre><h2 id="5-把文件添加到版本库"><a href="#5-把文件添加到版本库" class="headerlink" title="5. 把文件添加到版本库"></a>5. 把文件添加到版本库</h2><pre class=" language-shell"><code class="language-shell">$ git add <file-name>$ git commit -m "description"</code></pre><p><strong>注意</strong>  可以多次<code>git add </code>，最后一次<code>git commit</code></p><h2 id="6-查看工作区当前状态"><a href="#6-查看工作区当前状态" class="headerlink" title="6. 查看工作区当前状态"></a>6. 查看工作区当前状态</h2><pre class=" language-shell"><code class="language-shell">$ git status</code></pre><h2 id="7-时光穿梭"><a href="#7-时光穿梭" class="headerlink" title="7. 时光穿梭"></a>7. 时光穿梭</h2><pre class=" language-shell"><code class="language-shell">$ git reset --hard commit-id</code></pre><h3 id="7-1-确定版本回退commit-id"><a href="#7-1-确定版本回退commit-id" class="headerlink" title="7.1 确定版本回退commit-id"></a>7.1 确定版本回退commit-id</h3><h4 id="7-1-1-通过查看提交历史"><a href="#7-1-1-通过查看提交历史" class="headerlink" title="7.1.1 通过查看提交历史"></a>7.1.1 通过查看提交历史</h4><pre class=" language-shell"><code class="language-shell">$ git log</code></pre><p>按<code>q</code>退出查看 </p><h4 id="7-1-2-简化显示提交历史"><a href="#7-1-2-简化显示提交历史" class="headerlink" title="7.1.2 简化显示提交历史"></a>7.1.2 简化显示提交历史</h4><pre class=" language-shell"><code class="language-shell">$ git log --pretty=oneline</code></pre><p><code>HEAD</code>，当前版本  </p><p><code>HEAD^</code>，上个版本  </p><p><code>HEAD^^</code>，上上个版本  </p><p><code>HEAD~100</code>，往上100个版本</p><h3 id="7-2-确定重返未来commit-id"><a href="#7-2-确定重返未来commit-id" class="headerlink" title="7.2 确定重返未来commit-id"></a>7.2 确定重返未来commit-id</h3><h4 id="7-2-1-通过查看命令历史"><a href="#7-2-1-通过查看命令历史" class="headerlink" title="7.2.1 通过查看命令历史"></a>7.2.1 通过查看命令历史</h4><pre class=" language-shell"><code class="language-shell">$ git reflog</code></pre><h2 id="8-工作区与暂存区"><a href="#8-工作区与暂存区" class="headerlink" title="8. 工作区与暂存区"></a>8. 工作区与暂存区</h2><p>工作区就是电脑中能看到的目录，工作区有一个隐藏目录<code>.git</code>，这是Git的版本库 </p><h3 id="8-1-管理修改"><a href="#8-1-管理修改" class="headerlink" title="8.1 管理修改"></a>8.1 管理修改</h3><h4 id="8-1-1-修改但未add"><a href="#8-1-1-修改但未add" class="headerlink" title="8.1.1 修改但未add"></a>8.1.1 修改但未add</h4><ul><li>比较工作区与暂存区（即上次git add的内容）的不同  </li></ul><p>比较所有修改文件的不同</p><pre class=" language-shell"><code class="language-shell">$ git diff</code></pre><p>比较指定修改文件的不同</p><pre class=" language-shell"><code class="language-shell">$ git diff <file-name></code></pre><h4 id="8-1-2-修改已add但未commit"><a href="#8-1-2-修改已add但未commit" class="headerlink" title="8.1.2 修改已add但未commit"></a>8.1.2 修改已add但未commit</h4><ul><li>比较暂存区与仓库分支（上次git commit）的不同<pre class=" language-shell"><code class="language-shell">$ git diff --staged</code></pre>或<pre class=" language-shell"><code class="language-shell">$ git diff --cached</code></pre></li></ul><h2 id="9-撤销修改"><a href="#9-撤销修改" class="headerlink" title="9. 撤销修改"></a>9. 撤销修改</h2><ul><li>场景1——工作区已修改但未add到暂存区  <pre class=" language-shell"><code class="language-shell">$ git checkout -- <file-name></code></pre>其实就是用版本库里的版本替换工作区的版本</li><li>场景2——工作区修改且已经git add到暂存区，分两步 <pre class=" language-shell"><code class="language-shell">$ git reset HEAD <file-name></code></pre>回到场景1，再按场景1操作</li><li>场景3：已经commit但没有推送到远程库——<strong>版本回退</strong></li></ul><h2 id="10-删除文件"><a href="#10-删除文件" class="headerlink" title="10. 删除文件"></a>10. 删除文件</h2><p>假设文件原已commit，目前情况是——已经在目录下手动或<code>$ rm &lt;file-name&gt;</code>删除文件</p><ul><li>选择一：确实要从版本库中删除该文件，分两步  </li></ul><p>第一步</p><pre class=" language-shell"><code class="language-shell">$ git rm <file-name></code></pre><p>或</p><pre class=" language-shell"><code class="language-shell">git add <file-name></code></pre><p>第二步</p><pre class=" language-shell"><code class="language-shell">$ git commit -m "description"</code></pre><ul><li>选择二：删错了，要恢复  <pre class=" language-shell"><code class="language-shell">$ git checkout -- <file-name></code></pre>其实就是用版本库里的版本替换工作区的版本</li></ul><h2 id="11-远程仓库"><a href="#11-远程仓库" class="headerlink" title="11. 远程仓库"></a>11. 远程仓库</h2><h3 id="11-1-创建SSH-Key"><a href="#11-1-创建SSH-Key" class="headerlink" title="11.1 创建SSH Key"></a>11.1 创建SSH Key</h3><pre class=" language-shell"><code class="language-shell">$ ssh-keygen -t rsa -C "youremail@example.com"</code></pre><p><strong>补充</strong>  在用户主目录下(<code>cd</code>)  </p><p><code>$ ls -ah</code>可见<code>.ssh</code>目录  </p><p><code>$ cd .ssh</code>可见<code>id_rsa</code>(私钥不能泄露)和<code>id_rsa.pub</code>(公钥可公开)</p><h3 id="11-2-关联远程仓库"><a href="#11-2-关联远程仓库" class="headerlink" title="11.2 关联远程仓库"></a>11.2 关联远程仓库</h3><pre class=" language-shell"><code class="language-shell">$ git remote add origin git@github.com:username/repositoryname.git</code></pre><p>或</p><pre class=" language-shell"><code class="language-shell">$ git remote add origin https://github.com/username/repositoryname.git</code></pre><p>远程库默认名字为<code>origin</code></p><h3 id="11-3-删除已经关联的远程库"><a href="#11-3-删除已经关联的远程库" class="headerlink" title="11.3 删除已经关联的远程库"></a>11.3 删除已经关联的远程库</h3><pre class=" language-shell"><code class="language-shell">git remote rm remote-name</code></pre><p>若远程库默认名字为<code>origin</code>，则</p><pre class=" language-shell"><code class="language-shell">git remote rm origin</code></pre><h3 id="11-4-推送到远程仓库"><a href="#11-4-推送到远程仓库" class="headerlink" title="11.4 推送到远程仓库"></a>11.4 推送到远程仓库</h3><ul><li>第一次推送到GitHub  <pre class=" language-shell"><code class="language-shell">$ git push -u origin master</code></pre>推送master分支</li><li>后续推送<pre class=" language-shell"><code class="language-shell">$ git push origin master</code></pre>不再使用参数<code>-u</code></li></ul><h3 id="11-5-从远程库克隆"><a href="#11-5-从远程库克隆" class="headerlink" title="11.5 从远程库克隆"></a>11.5 从远程库克隆</h3><pre class=" language-shell"><code class="language-shell">$ git clone git@github.com:username/repositoryname.git</code></pre><p>或  </p><pre class=" language-shell"><code class="language-shell">$ git clone https://github.com/username/repositoryname.git</code></pre><h2 id="12-分支管理"><a href="#12-分支管理" class="headerlink" title="12. 分支管理"></a>12. 分支管理</h2><h3 id="12-1-查看分支"><a href="#12-1-查看分支" class="headerlink" title="12.1 查看分支"></a>12.1 查看分支</h3><pre class=" language-shell"><code class="language-shell">$ git branch</code></pre><h3 id="12-2-创建分支"><a href="#12-2-创建分支" class="headerlink" title="12.2 创建分支"></a>12.2 创建分支</h3><pre class=" language-shell"><code class="language-shell">$ git branch <branch-name></code></pre><h3 id="12-3-切换分支"><a href="#12-3-切换分支" class="headerlink" title="12.3 切换分支"></a>12.3 切换分支</h3><pre class=" language-shell"><code class="language-shell">$ git checkout <branch-name></code></pre><h3 id="12-4-创建-切换分支"><a href="#12-4-创建-切换分支" class="headerlink" title="12.4 创建+切换分支"></a>12.4 创建+切换分支</h3><pre class=" language-shell"><code class="language-shell">$ git checkout -b <branch-name></code></pre><h3 id="12-5-合并某分支到当前分支"><a href="#12-5-合并某分支到当前分支" class="headerlink" title="12.5 合并某分支到当前分支"></a>12.5 合并某分支到当前分支</h3><pre class=" language-shell"><code class="language-shell">$ git merge <branch-name></code></pre><h3 id="12-6-普通模式合并分支"><a href="#12-6-普通模式合并分支" class="headerlink" title="12.6 普通模式合并分支"></a>12.6 普通模式合并分支</h3><pre class=" language-shell"><code class="language-shell">$ git merge --no-ff -m "description" <branch-name></code></pre><p>通常进行分支合并时，如果可以，Git会使用<code>Fast forward</code>模式，删除分支后，分支历史信息会丢失  </p><p><code>--no-ff</code>表示禁用<code>Fast forward</code>模式，能看出曾做过合并</p><h3 id="12-7-删除分支"><a href="#12-7-删除分支" class="headerlink" title="12.7 删除分支"></a>12.7 删除分支</h3><pre class=" language-shell"><code class="language-shell">$ git branch -d <branch-name></code></pre><h3 id="12-8-强行删除分支"><a href="#12-8-强行删除分支" class="headerlink" title="12.8 强行删除分支"></a>12.8 强行删除分支</h3><pre class=" language-shell"><code class="language-shell">$ git branch -D <branch-name></code></pre><h3 id="12-9-查看分支合并图"><a href="#12-9-查看分支合并图" class="headerlink" title="12.9 查看分支合并图"></a>12.9 查看分支合并图</h3><pre class=" language-shell"><code class="language-shell">$ git log --graph</code></pre><p>简洁查看</p><pre class=" language-shell"><code class="language-shell">$ git log --graph --pretty=oneline --abbrev-commit</code></pre><h3 id="12-10-Bug分支"><a href="#12-10-Bug分支" class="headerlink" title="12.10 Bug分支"></a>12.10 Bug分支</h3><p>假设场景——设A为游戏软件  </p><ol><li>master 上面发布的是A的1.0版本</li><li>dev 上开发的是A的2.0版本</li><li>这时，用户反映 1.0版本存在漏洞，有人利用这个漏洞开外挂</li><li>需要从dev切换到master去填这个漏洞，正常必须先提交dev目前的工作，才能切换</li><li>而dev的工作还未完成，不想提交，所以先把dev的工作stash一下。然后切换到master</li><li>在master建立分支issue101并切换</li><li>在issue101上修复漏洞</li><li>修复后，在master上合并并删除issue101</li><li>切回dev，恢复原本工作，继续工作</li></ol><h3 id="12-11-保存工作现场"><a href="#12-11-保存工作现场" class="headerlink" title="12.11 保存工作现场"></a>12.11 保存工作现场</h3><pre class=" language-shell"><code class="language-shell">$ git stash</code></pre><h3 id="12-12-查看保存的工作现场"><a href="#12-12-查看保存的工作现场" class="headerlink" title="12.12 查看保存的工作现场"></a>12.12 查看保存的工作现场</h3><pre class=" language-shell"><code class="language-shell">$ git stash list</code></pre><h3 id="12-13-恢复工作现场"><a href="#12-13-恢复工作现场" class="headerlink" title="12.13 恢复工作现场"></a>12.13 恢复工作现场</h3><pre class=" language-shell"><code class="language-shell">$ git stash apply</code></pre><h3 id="12-14-删除工作现场"><a href="#12-14-删除工作现场" class="headerlink" title="12.14 删除工作现场"></a>12.14 删除工作现场</h3><pre class=" language-shell"><code class="language-shell">$ git stash drop</code></pre><h3 id="12-15-恢复并删除工作现场"><a href="#12-15-恢复并删除工作现场" class="headerlink" title="12.15 恢复并删除工作现场"></a>12.15 恢复并删除工作现场</h3><pre class=" language-shell"><code class="language-shell">git stash pop</code></pre><h3 id="12-16-Feature分支"><a href="#12-16-Feature分支" class="headerlink" title="12.16 Feature分支"></a>12.16 Feature分支</h3><p>每添加一个新功能，最好新建一个feature分支，在上面开发完成后，合并，最后，删除该feature分支</p><h2 id="13-多人协作"><a href="#13-多人协作" class="headerlink" title="13. 多人协作"></a>13. 多人协作</h2><h3 id="13-1-多人协作通常的工作模式"><a href="#13-1-多人协作通常的工作模式" class="headerlink" title="13.1 多人协作通常的工作模式"></a>13.1 多人协作通常的工作模式</h3><ol><li>先试图推送自己的修改<code>git push</code></li><li>若推送失败，则远程分支比本地分支更新，<code>git pull</code>拉取远程分支试图合并</li><li>若合并有冲突，则解决冲突，并在本地提交(<code>add</code> 和 <code>commit</code>)</li><li>若没有冲突或解决了冲突，再次推送<code>git push</code></li></ol><h3 id="13-2-查看远程库信息"><a href="#13-2-查看远程库信息" class="headerlink" title="13.2 查看远程库信息"></a>13.2 查看远程库信息</h3><pre class=" language-shell"><code class="language-shell">$ git remote</code></pre><p>详细查看</p><pre class=" language-shell"><code class="language-shell">git remote -v</code></pre><h3 id="13-3-本地推送分支"><a href="#13-3-本地推送分支" class="headerlink" title="13.3 本地推送分支"></a>13.3 本地推送分支</h3><pre class=" language-shell"><code class="language-shell">$ git push origin <branch-name></code></pre><h3 id="13-3-在本地创建和远程分支对应的分支"><a href="#13-3-在本地创建和远程分支对应的分支" class="headerlink" title="13.3 在本地创建和远程分支对应的分支"></a>13.3 在本地创建和远程分支对应的分支</h3><pre class=" language-shell"><code class="language-shell">$ git checkout -b <branch-name> origin/<branch-name></code></pre><h3 id="13-4-建立本地分支和远程分支的关联"><a href="#13-4-建立本地分支和远程分支的关联" class="headerlink" title="13.4 建立本地分支和远程分支的关联"></a>13.4 建立本地分支和远程分支的关联</h3><pre class=" language-shell"><code class="language-shell">$ git branch --set-upstream <branch-name> origin/<branch-name></code></pre><p>或  </p><pre class=" language-shell"><code class="language-shell">$ git branch --set-upstream-to=origin/<branch-name> <branch-name></code></pre><h3 id="13-5-从远程抓取分支"><a href="#13-5-从远程抓取分支" class="headerlink" title="13.5 从远程抓取分支"></a>13.5 从远程抓取分支</h3><pre class=" language-shell"><code class="language-shell">$ git pull</code></pre><h2 id="14-Rebase“变基”"><a href="#14-Rebase“变基”" class="headerlink" title="14. Rebase“变基”"></a>14. Rebase“变基”</h2><pre class=" language-shell"><code class="language-shell">$ git rebase</code></pre><p>把分叉的提交历史“整理”成一条直线，看上去更直观。缺点是本地的分叉提交已经被修改过了。  </p><p>只对尚未推送或尚未分享给别人的本地修改执行变基操作清理历史，从不对已推送至别处的提交执行变基操作</p><h2 id="15-标签管理"><a href="#15-标签管理" class="headerlink" title="15. 标签管理"></a>15. 标签管理</h2><p>发布一个版本时，我们通常先在版本库中打一个标签（<code>tag</code>），这样，就唯一确定了打标签时刻的版本  </p><p>将来无论什么时候，取某个标签的版本，就是把那个打标签的时刻的历史版本取出来。所以，标签也是版本库的一个快照</p><h3 id="15-1-创建标签"><a href="#15-1-创建标签" class="headerlink" title="15.1 创建标签"></a>15.1 创建标签</h3><pre class=" language-shell"><code class="language-shell">$ git tag <tag-name></code></pre><p>在最新commit上打一个标签  </p><pre class=" language-shell"><code class="language-shell">$ git tag <tag-name> commit-id</code></pre><p>在对应的commit_id上打一个新标签</p><h3 id="15-2-创建带有说明的标签"><a href="#15-2-创建带有说明的标签" class="headerlink" title="15.2 创建带有说明的标签"></a>15.2 创建带有说明的标签</h3><pre class=" language-shell"><code class="language-shell">$ git tag -a <tag-name> -m "description" commit-id</code></pre><p><code>-a</code>指定标签名，<code>-m</code>指定说明文字  </p><h3 id="15-3-查看所有标签"><a href="#15-3-查看所有标签" class="headerlink" title="15.3 查看所有标签"></a>15.3 查看所有标签</h3><pre class=" language-shell"><code class="language-shell">$ git tag</code></pre><h3 id="15-4-查看对应标签的信息"><a href="#15-4-查看对应标签的信息" class="headerlink" title="15.4 查看对应标签的信息"></a>15.4 查看对应标签的信息</h3><pre class=" language-shell"><code class="language-shell">$ git show <tag-name></code></pre><p><strong>注意</strong>标签总是和某个commit挂钩。如果这个commit既出现在master分支，又出现在dev分支，那么在这两个分支上都可以看到这个标签。</p><h3 id="15-5-操作标签"><a href="#15-5-操作标签" class="headerlink" title="15.5 操作标签"></a>15.5 操作标签</h3><h4 id="15-5-1-推送某个标签到远程"><a href="#15-5-1-推送某个标签到远程" class="headerlink" title="15.5.1 推送某个标签到远程"></a>15.5.1 推送某个标签到远程</h4><pre class=" language-shell"><code class="language-shell">$ git push origin <tag-name></code></pre><h4 id="15-5-2-一次性推送全部尚未推送的标签到远程"><a href="#15-5-2-一次性推送全部尚未推送的标签到远程" class="headerlink" title="15.5.2 一次性推送全部尚未推送的标签到远程"></a>15.5.2 一次性推送全部尚未推送的标签到远程</h4><pre class=" language-shell"><code class="language-shell">git push origin --tags</code></pre><h4 id="15-5-3-删除一个本地标签"><a href="#15-5-3-删除一个本地标签" class="headerlink" title="15.5.3 删除一个本地标签"></a>15.5.3 删除一个本地标签</h4><pre class=" language-shell"><code class="language-shell">$ git tag -d <tag-name></code></pre><h4 id="15-5-4-删除一个远程标签"><a href="#15-5-4-删除一个远程标签" class="headerlink" title="15.5.4 删除一个远程标签"></a>15.5.4 删除一个远程标签</h4><p>先从本地删除  </p><pre class=" language-shell"><code class="language-shell">$ git tag -d <tag-name></code></pre><p>再从远程删除</p><pre class=" language-shell"><code class="language-shell">$ git push origin :refs/tags/<tag-name></code></pre><h2 id="16-使用GitHub"><a href="#16-使用GitHub" class="headerlink" title="16. 使用GitHub"></a>16. 使用GitHub</h2><p>如何参与一个开源项目  </p><p><code>Fork</code>任意开源库 ——&gt; 从自己的账户下<code>clone</code> ——&gt; 修复bug或者新增一个功能 ——&gt; 若希望官方库接受你的修改，可以在GitHub上发起一个<code>pull request</code></p><h2 id="17-本地库既关联GitHub，又关联码云"><a href="#17-本地库既关联GitHub，又关联码云" class="headerlink" title="17. 本地库既关联GitHub，又关联码云"></a>17. 本地库既关联GitHub，又关联码云</h2><p>如原来已经关联了默认名<code>origin</code>的GitHub  </p><ol><li>先删除已关联的名为<code>origin</code>的远程库：</li></ol><pre class=" language-shell"><code class="language-shell">$ git remote rm origin</code></pre><ol start="2"><li>然后，先关联GitHub的远程库：</li></ol><pre class=" language-shell"><code class="language-shell">$ git remote add github git@github.com:username/repositoryname.git</code></pre><p>注意，远程库的名称叫<code>github</code>，不叫<code>origin</code>了  </p><ol start="3"><li>接着，再关联码云的远程库：</li></ol><pre class=" language-shell"><code class="language-shell">$ git remote add gitee git@gitee.com:username/repositoryname.git</code></pre><p>同样注意，远程库的名称叫<code>gitee</code>，不叫<code>origin</code>了  </p><p><strong>注意</strong>  多个关联后以上所以命令含的<code>origin</code>都换成相应的<code>github</code>或<code>gitee</code>  </p><p>如果要推送到GitHub，使用命令：</p><pre class=" language-shell"><code class="language-shell">$ git push github master</code></pre><p>如果要推送到码云，使用命令：</p><pre class=" language-shell"><code class="language-shell">$ git push gitee master</code></pre><h2 id="18-自定义Git"><a href="#18-自定义Git" class="headerlink" title="18. 自定义Git"></a>18. 自定义Git</h2><h3 id="18-1-显示颜色"><a href="#18-1-显示颜色" class="headerlink" title="18.1 显示颜色"></a>18.1 显示颜色</h3><p>让Git显示颜色，会让命令输出看起来更醒目：  </p><pre class=" language-shell"><code class="language-shell">$ git config --global color.ui true</code></pre><h3 id="18-2-忽略特殊文件"><a href="#18-2-忽略特殊文件" class="headerlink" title="18.2 忽略特殊文件"></a>18.2 忽略特殊文件</h3><p><a href="https://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000/0013758404317281e54b6f5375640abbb11e67be4cd49e0000">见廖老师教程</a></p><h3 id="18-3-配置别名"><a href="#18-3-配置别名" class="headerlink" title="18.3 配置别名"></a>18.3 配置别名</h3><p>如</p><ul><li>用<code>git st</code>就表示<code>git status</code><pre class=" language-shell"><code class="language-shell">$ git config --global alias.st status</code></pre></li><li>配置一个<code>git last</code>，让其显示最后一次提交信息：<pre class=" language-shell"><code class="language-shell">$ git config --global alias.last 'log -1'</code></pre></li><li>甚至还有人丧心病狂地把lg配置成了：<pre class=" language-shell"><code class="language-shell">$ git config --global alias.lg "log --color --graph --pretty=format:'%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)<%an>%Creset' --abbrev-commit"</code></pre>试试<code>git lg</code>的效果，很炫酷</li></ul><h3 id="18-4-配置文件"><a href="#18-4-配置文件" class="headerlink" title="18.4 配置文件"></a>18.4 配置文件</h3><ul><li>配置Git的时候，加上<code>--global</code>是针对当前用户起作用的，如果不加，那只针对当前的仓库起作用  </li><li>查看用户的配置信息：<pre class=" language-shell"><code class="language-shell">$ git config --global --list</code></pre>要查看当前仓库的，把<code>global</code>改成<code>local</code>就好</li><li>配置文件放哪了？每个仓库的Git配置文件都放在<code>.git/config</code>文件中：<code>$ cat .gitconfig</code></li><li>别名就在<code>alias</code>后面，要删除别名，直接把对应的行删掉即可</li></ul><h3 id="18-5-搭建Git服务器"><a href="#18-5-搭建Git服务器" class="headerlink" title="18.5 搭建Git服务器"></a>18.5 搭建Git服务器</h3><p>GitHub就是一个免费托管开源代码的远程仓库  </p><p>但是对于某些视源代码如生命的商业公司来说，既不想公开源代码，又舍不得给GitHub交保护费，那就只能自己搭建一台Git服务器作为私有仓库使用  </p><p><a href="https://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000/00137583770360579bc4b458f044ce7afed3df579123eca000">搭建见廖老师教程</a></p>]]></content>
      
      
      <categories>
          
          <category> 软件工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
